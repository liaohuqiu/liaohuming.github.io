<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Keep@liaohuming.net]]></title>
  <subtitle><![CDATA[One should always keep reading, keep writing and keep thinking.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liaohuming.net/"/>
  <updated>2016-04-19T15:19:26.403Z</updated>
  <id>http://liaohuming.net/</id>
  
  <author>
    <name><![CDATA[liaohuming]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[多思考，勤笔记]]></title>
    <link href="http://liaohuming.net/2016/03/31/20160331-%E5%A4%9A%E6%80%9D%E8%80%83%EF%BC%8C%E5%8B%A4%E7%AC%94%E8%AE%B0/"/>
    <id>http://liaohuming.net/2016/03/31/20160331-多思考，勤笔记/</id>
    <published>2016-04-01T01:49:21.000Z</published>
    <updated>2016-04-19T15:19:26.403Z</updated>
    <content type="html"><![CDATA[<p>好像有这么个说法：“代码都在网上，学会google你就学会了coding”，确实是如此，学会向搜索引擎提问，问得越到位，得到的答案越精准而且快速。这不仅限于coding，所有一切，只要有疑问的都可以向搜索引擎提问，或多或少都会有些帮助，前提是客观的搜索引擎。然而实际生活中，并不是人人都善于利用搜索引擎来解决问题，大多的时候都喜欢让人代工，我自己以前就常常这么干，明明自己上网搜一下就可以解决的问题，却总是问别人，想着谁能告诉你怎么做。这就是典型的不思考。虽然一般情况下强调学习要多提问，然而多提问很多时候并不一定就是好的，更要注重提问的质量。能自己解决的尽量自己解决，不要让自己成为一个一遇到问题就问人的问题机器，要多思考，注重独自解决问题的能力，求助别人的时候，要搞清楚自己要问的是什么，而不是稀里糊涂的把锅一甩，这不是提问，这是让别人给你做了。</p>
<p>对于coding这件事，不止于会问，如果想要有提高，夯实基础和总结积累是两个很重要的方面。夯实基础即是要多看书，看好书，看经典。把基本的原理，概念要理解透。总结积累即是要在实践的过程中，对每次遇到的问题、困难进行总结提炼，遇到的问题是什么，自己是怎么解决的，总结的一个好方式就是做笔记写备忘，所谓好记性不如烂笔头，与其相同的问题一次次重复地遇到不如把每次遇到的问题及解决方法都记录下来，一是加深了理解，二来把东西放在自家后院，那才是自己的，用起来或者平时翻出来看看也是方便。</p>
<p>刚刚开始写笔记的时候常常会觉得，这个东西太简单了，用一次就记住了，没有必要去写。其实并不是这样。简单又何妨，就我个人经验而言，只要是一开始把你难住的问题，往往还会有第二次，第三次。所以，多思考，勤笔记，下次再遇则有迹可循。只有足够努力，方显毫不费力。想做一件事，任何时候都不算太晚，除非只是想想而已。</p>
<p>呵呵。口号喊完了，该开始写笔记了。我将在这篇笔记中不断地记录自己平时在使用C++时遇到并解决的小问题，并不需要特意去花上半天一天来总结，记录这一动作就发生在平时遇到问题并解决后。</p>
<p><em>@2016年3月31日21:56:01</em></p>
<hr>
<p><strong>CString与string的区别及转化</strong></p>
<p><em>关于CString类型：</em>CString是MFC的类，利用MFC进行编程时会经常用到，而一些标准C/C++库函数是不能直接对CString类型进行操作的，所以经常遇到将CString类型转化char*等其他数据类型的情况。</p>
<p><em>关于string类型：</em>标准C中是不存在string类型的，string是标准C++扩充字符串操作的一个类，但是标准C中有<code>&lt;string.h&gt;</code>这个头文件，在里面定义了一些经常用到的操作字符串的函数，如：strcpy、strcat、strcmp等，这些函数的操作对象都是char*指向的字符串。 </p>
<p>而C++的string类（头文件是<code>&lt;string&gt;</code>）操作对象是string类型字符串，该类重载了一些运算符，添加了一些字符串操作成员函数，使得操作字符串更加方便。有时候需要将string串和char*串配合使用，因此也会涉及到这两个类型的转化问题。</p>
<p>上述是CSting、string.h和string的区别，要对CString和string类型的字符串进行转换，首先将类型转化为<code>char*</code>类型，因为<code>char*</code>是不同类型之间的桥梁。得到<code>char*</code>类型，转化为其他类型就非常容易了。</p>
<p>1、string to char</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">255</span>];</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"string to char"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(ch, str.c_str());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>2、char to string</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">255</span>] = <span class="string">"ch to string"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>(ch);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>3、string to CString（在Unicode和多字节字符集环境下）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"string2CString"</span>;</span><br><span class="line">CString cstr;</span><br><span class="line">cstr = str.c_str();</span><br><span class="line">MessageBox(cstr);</span><br></pre></td></tr></table></figure>
<p>4、CString to string（在Unicode和多字节字符集环境下）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CString cstr = _T(<span class="string">"Cstring2string"</span>);</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str = (CStringA)cstr;</span><br></pre></td></tr></table></figure>
<p>5、string to double</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string to double</span></span><br><span class="line"><span class="built_in">string</span> = <span class="string">"3.14159"</span>;</span><br><span class="line"><span class="keyword">double</span> PI=atof(str.c_str());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将double值转换为string，string转double，或者其他类型</span></span><br><span class="line"><span class="keyword">double</span> length=<span class="number">5.38725</span>;</span><br><span class="line"><span class="built_in">string</span> tempStr;</span><br><span class="line"><span class="built_in">stringstream</span> ssStr;</span><br><span class="line">ssStr&lt;&lt;length;</span><br><span class="line">ssStr&gt;&gt;tempStr;</span><br><span class="line">CString msg;</span><br><span class="line">msg=tempStr.c_str();</span><br><span class="line">MessageBox(msg);</span><br><span class="line">ssStr.clear();</span><br></pre></td></tr></table></figure>
<p>6、将int转换为CString</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">123</span>;</span><br><span class="line">CString intStr;</span><br><span class="line">intStr.Format(_T(<span class="string">"%d"</span>),num);</span><br><span class="line">MessageBox(intStr);</span><br></pre></td></tr></table></figure>
<p>7、 CString转char*（解决在Unicode字符集环境下中文乱码问题）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unicode环境下将CString转换成char*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">CStringToChar</span><span class="params">(CString inputStr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//获取宽字节字符的大小，大小是按字节计算的</span></span><br><span class="line">    DWORD dwLength=WideCharToMultiByte(CP_ACP,NULL,inputStr,<span class="number">-1</span>,NULL,<span class="number">0</span>,NULL,FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为多字节字符数组申请空间，数组大小为按字节计算的宽字节字节大小</span></span><br><span class="line">    <span class="keyword">char</span> *charStr;</span><br><span class="line">    charStr = new <span class="keyword">char</span>[dwLength];</span><br><span class="line">    <span class="keyword">if</span>(!charStr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []charStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//宽字节编码转换成多字节编码</span></span><br><span class="line">    WideCharToMultiByte(CP_ACP,<span class="literal">NULL</span>,inputStr,<span class="number">-1</span>,charStr,dwLength,<span class="literal">NULL</span>,FALSE);</span><br><span class="line">    return charStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、MFC 多字节字符集环境下 CString转char*</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CString Length=<span class="string">"10"</span>;</span><br><span class="line"><span class="keyword">char</span> *LengthStr=Length.GetBuffer(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>9、Unicode环境下将 CString转int</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CString str=_T(<span class="string">"123"</span>);</span><br><span class="line"><span class="keyword">int</span> i=_ttoi(str);</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C中字符串操作</strong></p>
<p>1、由于字符串是数组类型，所以两个字符串赋值运算不能直接用“=”（除了初始化时），字符串的比较也不能直接用”==”,，字符串的拼接也不能用”+”,在C中有专门的操作函数，如：strcpy、strcat、strcmp。</p>
<p>char <em>strcpy(char </em>strDest,const char *strSrc); //是字符串复制函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strDest[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> strSrc[<span class="number">255</span>] = <span class="string">"World!"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(strDest,strSrc); <span class="comment">// strDest=World!</span></span><br></pre></td></tr></table></figure>
<p>char <em>strcat(char </em>strDest,const char *strSrc);    //是字符串拼接函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strDest[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> strSrc[<span class="number">255</span>] = <span class="string">" World!"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(strDest,strSrc); <span class="comment">// strDest=Hello World!</span></span><br></pre></td></tr></table></figure>
<p>int strcmp(const char <em>str1, const char </em>str2 ; //是字符串比较函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">255</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">255</span>] = <span class="string">" World!"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcat</span>(str1,str2)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 not equal to str2!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、字符串查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> setEndFindStr=<span class="string">"END SETS"</span>;</span><br><span class="line"><span class="keyword">if</span> (lineStr.find(nodesFindStr) &lt; lineStr.length())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; find <span class="string">"END SETS"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>格式化字符串</strong></p>
<p>1、用sscanf</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getline(_inputFile, firstLineStr);</span><br><span class="line"><span class="keyword">char</span> setType[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">char</span> setName[<span class="number">255</span>];</span><br><span class="line"><span class="built_in">sscanf</span>(firstLineStr.c_str(), <span class="string">"%*[^,],%[^,],%[^,],%*[^,]"</span>, &amp;(setName),&amp;(setType));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解释一下，在这里firstLineStr=CMBLOCK,ELESET1 ,ELEM,28 !users element component definition</span></span><br><span class="line"><span class="comment">//格式化字符串后，setName==ELESET1，setType==ELEM</span></span><br><span class="line"><span class="comment">//%[]类似于一个正则表达式。[a-z]表示读取a-z的所有字符，[^a-z]表示读取除a-z以外的所有字符。</span></span><br><span class="line"><span class="comment">//所以此处``%*[^,]``表示满足``[]``里的条件将被过滤掉，不会向目标参数中写入值。</span></span><br><span class="line"><span class="comment">//即：将在遇到第一个``,``之前的（不为``,``的）字符全部过滤掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他简单用法</span></span><br><span class="line"><span class="comment">//Splitting the string,e.g."*node(1,0.292676,0.078422,-0.07,0,0,0,5,86)"</span></span><br><span class="line"><span class="built_in">sscanf</span>(firstLineStr.c_str(), <span class="string">"*node(%d,%lf,%lf,%lf,%*s,%*s,%*s,%*s,%*s"</span>,</span><br><span class="line">	&amp;(node.id), &amp;(node.coordinate[<span class="number">0</span>]), &amp;(node.coordinate[<span class="number">1</span>]), &amp;(node.coordinate[<span class="number">2</span>]));</span><br></pre></td></tr></table></figure>
<p>2、用strtok<br>strtok的函数原型为char <em>strtok(char </em>s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成中文就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string lineStr="3	-49	17	-19	26	-29	33	-34"，以“ ”作为分隔符</span></span><br><span class="line"><span class="keyword">char</span> lineData[<span class="number">255</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(lineData, lineStr.c_str());</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *delimter = <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">char</span> *item;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; itemCounter;</span><br><span class="line">item = strtok(lineData, delimter);</span><br><span class="line"><span class="keyword">while</span> (item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//把char类型的转换成int类型存入临时变量</span></span><br><span class="line">	<span class="keyword">int</span> nodeInt = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">nodeStr</span><span class="params">(item)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">nodeSs</span><span class="params">(nodeStr)</span></span>;</span><br><span class="line">	nodeSs &gt;&gt; nodeInt;</span><br><span class="line">	itemCounter.push_back(nodeInt);</span><br><span class="line">	item = strtok(NULL, delimter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、用AfxExtractSubString</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考PDS系统代码，MatlabSample.cpp</span></span><br><span class="line"><span class="comment">//以tab键为分割符，将apdl几何变量存到容器</span></span><br><span class="line">CString tempName;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=ugVariableNum; i&lt;(ugVariableNum+apdlVariableNum); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//tempName得到的字符串，tempStr完整待分割的字符串，i取第几个放在tempName</span></span><br><span class="line">	AfxExtractSubString(tempName,tempStr,i,<span class="string">'\t'</span>); </span><br><span class="line">	apdlVariableName.push_back(tempName);</span><br><span class="line">	<span class="comment">/*MessageBox(tempName);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、用Cstring中的Find()、Mid()、Replace()、Right()、Left()等用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考机场安保系统代码，Logical_Relationship.cpp</span></span><br><span class="line"><span class="keyword">int</span> charPOS=indexstr_old.Find(<span class="string">' '</span>);</span><br><span class="line">Cstring temp=indexstr_old.Right(indexstr_old.GetLength()-charPOS<span class="number">-1</span>);</span><br><span class="line">index=atoi(temp)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>写文件的几种方式</strong></p>
<p>1、用FILE<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *outputFile = <span class="literal">NULL</span>;</span><br><span class="line">outputFile = fopen(<span class="string">"test.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outputFile, <span class="string">"%d\t%d\t%d\t%d\n"</span>, dimension, <span class="number">3</span>, nodes.size(), tria3.size());</span><br><span class="line">fclose(outputFile);</span><br></pre></td></tr></table></figure></p>
<p>2、用ofstream</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">"test.txt"</span>,ofstream::out)</span></span>;	</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">"# vtk DataFile Version 2.0"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">	&lt;&lt; <span class="string">"VTK file"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">	&lt;&lt; <span class="string">"ASCII"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">	&lt;&lt; <span class="string">"DATASET UNSTRUCTURED_GRID"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">	&lt;&lt; <span class="string">"POINTS "</span> &lt;&lt; nodes.size() &lt;&lt; <span class="string">" float"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	ofs &lt;&lt; nodes[i].coordinate[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> </span><br><span class="line">	&lt;&lt; nodes[i].coordinate[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> </span><br><span class="line">	&lt;&lt; nodes[i].coordinate[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、用CStdioFile</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CStdioFile outPutFile( _T("temp.txt"),CFile::modeCreate | CFile::modeWrite | CFile::typeText );</span><br><span class="line"></span><br><span class="line">CString headStr=_T("!设置工作目录\n");</span><br><span class="line">outPutFile.WriteString(headStr);</span><br><span class="line"></span><br><span class="line">CString stressDataStr;</span><br><span class="line">stressDataStr.Format(_T("*cfopen,DATA-stress-result,txt,'%s'"),G_projectPath);</span><br><span class="line">outPutFile.WriteString(stressDataStr);</span><br><span class="line"></span><br><span class="line">outPutFile.Close();</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>读文件的几种方式</strong></p>
<p>1、用ifstream</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile;</span><br><span class="line">infile.open(filepath);</span><br><span class="line"><span class="keyword">if</span> (!infile.is_open()) </span><br><span class="line">&#123;</span><br><span class="line">	return <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> line = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (!infile.eof()) </span><br><span class="line">&#123;</span><br><span class="line">	getline(infile, line);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">infile.close();</span><br></pre></td></tr></table></figure>
<p>2、用CStdioFile</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CStdioFile apdlFile;</span><br><span class="line">CString apdlPath=_T(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!apdlFile.Open(apdlPath, CFile::modeRead))</span><br><span class="line">&#123;</span><br><span class="line">	::AfxMessageBox(_T(<span class="string">"文件打开失败。"</span>));</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString apdlStr = _T(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算文件的行数</span></span><br><span class="line"><span class="keyword">int</span> lineCount=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (apdlFile.ReadString(apdlStr))</span><br><span class="line">&#123;</span><br><span class="line">	lineCount++;</span><br><span class="line">&#125;</span><br><span class="line">apdlFile.Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件写入一个动态数组</span></span><br><span class="line">CString *apdlArray=new CString[lineCount];</span><br><span class="line">apdlFile.Open(apdlPath, CFile::modeRead)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> writeNumber=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (apdlFile.ReadString(apdlStr))</span><br><span class="line">&#123;</span><br><span class="line">	apdlArray[writeNumber]=apdlStr;</span><br><span class="line">	writeNumber++;</span><br><span class="line">&#125;</span><br><span class="line">apdlFile.Close();</span><br></pre></td></tr></table></figure>
<hr>
<p>@2016年4月5日10:09:41</p>
<p><strong>const 与 #define的比较</strong></p>
<p>C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：</p>
<ul>
<li><p>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。</p>
</li>
<li><p>有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。</p>
</li>
</ul>
<p>「规则1」在C++ 程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。</p>
<ul>
<li>常量定义规则</li>
</ul>
<p>「规则2」需要对外公开的常量放在头文件中，不需要对外公开的常量放在定义文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中。</p>
<p>「规则3」如果某一常量与其它常量密切相关，应在定义中包含这种关系，而不应给出一些孤立的值。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100 <span class="comment">// C语言的宏常量 </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span>; <span class="comment">// C++ 语言的const常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14159</span>; <span class="comment">// C++ 语言的const常量</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"><span class="comment">//argc=argument count</span></span><br><span class="line"><span class="comment">//argv=argument value</span></span></span><br></pre></td></tr></table></figure>
<hr>
<p>@ 2016年4月17日00:35:15</p>
<p>使用<code>getline(infile, lineStr);</code>时，如果infile文件中最后一行不是空行，则会死循环（跳不出循环），这可能是LmeTestTool中有空行没空行时计算出bug的症结之所在。有时间可以去检查一下代码，在这做个备忘。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile;</span><br><span class="line">infile.open(<span class="string">"RBF-Init-Data-Points.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> lineStr = <span class="string">""</span>;</span><br><span class="line">getline(infile, lineStr);</span><br><span class="line"><span class="keyword">while</span> (lineStr != <span class="string">""</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> lifeTemp = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sscanf</span>(lineStr.c_str(), <span class="string">"%d"</span>, &amp;(lifeTemp));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; lifeTemp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	lifeVector.push_back(lifeTemp);</span><br><span class="line">	getline(infile, lineStr);</span><br><span class="line">&#125;</span><br><span class="line">infile.close();</span><br></pre></td></tr></table></figure></p>
<p>@ 2016年4月19日10:59:09</p>
<p>检测EOF：成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(infile.eof())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; <span class="string">"已经到达文件尾！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好像有这么个说法：“代码都在网上，学会google你就学会了coding”，确实是如此，学会向搜索引擎提问，问得越到位，得到的答案越精准而且快速。这不仅限于coding，所有一切，只要有疑问的都可以向搜索引擎提问，或多或少都会有些帮助，前提是客观的搜索引擎。然而实际生活中，]]>
    </summary>
    
      <category term="C++" scheme="http://liaohuming.net/tags/C/"/>
    
      <category term="笔记" scheme="http://liaohuming.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Airplane, How does it fly-航空飞机飞行原理]]></title>
    <link href="http://liaohuming.net/2016/02/27/20160227-Airplane,%20How%20does%20it%20fly-%E8%88%AA%E7%A9%BA%E9%A3%9E%E6%9C%BA%E9%A3%9E%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://liaohuming.net/2016/02/27/20160227-Airplane, How does it fly-航空飞机飞行原理/</id>
    <published>2016-02-28T03:58:05.000Z</published>
    <updated>2016-03-23T02:13:58.721Z</updated>
    <content type="html"><![CDATA[<p>在前面<a href="http://liaohuming.net/2016/02/13/20160213-Aero%20Engine,%20How%20it%20works-%E8%88%AA%E7%A9%BA%E5%8F%91%E5%8A%A8%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">「Aero Engine, How it works-航空发动机工作原理」</a>一文中分享了若干个介绍航空发动机工作原理的视频，我们知道发动机是飞机的动力之源，发动机给飞机提供了动力，但是动力与飞机的飞行还不是一回事，有了动力之后如何产生升力，如何控制飞机的起飞降落，如何控制飞行方向呢？</p>
<p>简单说来，发动机给飞机提供了动力，而机翼在动力驱动下提供升力，其原理如下：一定速度的空气流到机翼前缘，分成上、下两股，分别沿机翼上、下表面流过，在机翼后缘重新会合向后流去。从机翼剖面形状可以看出，机翼上表面作成向上突出的曲线，而下翼面作成直线。显然，空气在上翼面流经的路程要比在下翼面流经的路程长，因此在上翼面的空气被迫以较快的速度流过。亦即气流流过机翼时，沿上翼面的流速快，沿下翼面的流速慢。根据物理学中的伯努利定律，流速快的地方压强低，反之，流速慢的地方压强高。这样，由于流过机翼上、下翼面的气流流速不一致，使作用在机翼上、下翼面上的压强不一致（下翼面压强大、上翼面压强小）而产生了向上的升力。显然，只要机翼与空气之间有相对运动，空气就能对机翼提供升力。而要保持机翼与空气的相对运动，就必须有持续的推动力来克服空气阻力，也就是必须要有提供动力的发动机。</p>
<p><img src="/img/Airplane How does it fly.jpg" alt="机翼产生升力的原理图"></p>
<p>本文分享几个非常精彩的视频，这些视频或以仿真模型或以板画动漫的方式，简单易懂地介绍及解释了飞机的飞行原理，在此分享与大家，更多视频可关注<a href="http://i.youku.com/liaohuming" target="_blank" rel="external">我的频道。</a></p>
<p>1）这个6分20秒的小视频，非常的精彩，它以板画动漫的形式，把飞机飞行过程中的 “空气动力学原理”、“飞机飞行的主要部件” 以及 “如何控制飞行的原理” 图文并茂简单易懂地展示出来。</p>
<iframe height="500" width="700" src="http://player.youku.com/player.php/sid/XMTQ4NDU4MzI4NA==/v.swf" frameborder="0" allowfullscreen></iframe>


<p>2）这是一个以飞机仿真模型为素材的视频，同样它简要的介绍了各结构的设计原理，升力产生的原理，起飞降落、飞行方向的控制原理等，同时通过仿真模型逼真的向大家展示了飞机飞行的过程，以及驾驶舱的调控，非常值得学习。</p>
<iframe height="500" width="700" src="http://player.youku.com/player.php/sid/XMTQ4MDczMTg2OA==/v.swf" frameborder="0" allowfullscreen></iframe>


<p>3）继前面两个视频介绍了飞机飞行的原理之后，本视频以震撼人心的方式展示了飞机起飞的过程和原理。</p>
<iframe height="500" width="700" src="http://player.youku.com/player.php/sid/XMTQ4MDc0MzE4MA==/v.swf" frameborder="0" allowfullscreen></iframe>


]]></content>
    <summary type="html">
    <![CDATA[<p>在前面<a href="http://liaohuming.net/2016/02/13/20160213-Aero%20Engine,%20How%20it%20works-%E8%88%AA%E7%A9%BA%E5%8F%91%E5%8A%A8%E6%9C%BA%E5%]]>
    </summary>
    
      <category term="航空发动机" scheme="http://liaohuming.net/tags/%E8%88%AA%E7%A9%BA%E5%8F%91%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="笔记" scheme="http://liaohuming.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows与Linux两种格式文件相互转化问题的简单解决方案]]></title>
    <link href="http://liaohuming.net/2016/02/18/20160218-Windows%E4%B8%8ELinux%E4%B8%A4%E7%A7%8D%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://liaohuming.net/2016/02/18/20160218-Windows与Linux两种格式文件相互转化问题的简单解决方案/</id>
    <published>2016-02-19T03:18:15.000Z</published>
    <updated>2016-02-25T04:02:07.107Z</updated>
    <content type="html"><![CDATA[<h3 id="u4E00-__u95EE_u9898_u63CF_u8FF0"><a href="#u4E00-__u95EE_u9898_u63CF_u8FF0" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h3><p>在<a href="http://liaohuming.net/2016/02/08/20160208-Linux%E4%B8%8B%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%AE%97%E4%BE%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/">「Linux下批量运行测试算例的简单实现」</a>一文中介绍了批量运行测试算例的方案，在其中我提到了修改每次计算的输入参数时，如果参数没有什么规律，只能手动的去修改输入参数文件，然而对于大数量级的测试次数，如果真的要手动去改输入参数，那是非常低效的，在经过两轮的手动改参数后我真受不了了，即便输入参数没有多少规律，也应尽量让程序来代工，手动改就是机械的浪费时间没有任何意义，把手动的过程用代码来实现虽然开始可能会费点时间，但这是个先苦后甜的过程，再者，相比机械的手动改参数，写程序还能多少有点技术性的收获，岂不更好。</p>
<p>这次遇到的问题是写了个代工程序，叫做<code>SubmitUpdater</code>，通过它来更新及生成大批量的Shell脚本文件，它们叫做<code>Submit-1.sh</code>-<code>Submit-N.sh</code>，这N份输入参数文件需要放到Linux服务器上进行计算。在Linux中执行.sh脚本的时候出现异常，具体表现为<code>/bin/bash^M: bad interpreter: No such file or directory</code>。在此对这个问题的解决方案进行简单总结，以做备忘。</p>
<h3 id="u4E8C-__u5177_u4F53_u8868_u73B0"><a href="#u4E8C-__u5177_u4F53_u8868_u73B0" class="headerlink" title="二. 具体表现"></a>二. 具体表现</h3><p>先看一眼<code>Submit-1.sh</code>里面的内容，很简单的Shell脚本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">290</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> </span><br><span class="line">-M <span class="number">0.01</span> -U -Q -t <span class="number">0.1</span> -T <span class="number">0.05</span> -d <span class="number">1000</span> -v <span class="number">1513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> </span><br><span class="line">-g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> -i <span class="number">0.04</span> -l <span class="number">0.01</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> </span><br><span class="line">-K <span class="number">0.010000</span></span><br></pre></td></tr></table></figure>
<p>这是执行<code>Submit-1.sh</code>的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmliao@songdyn:~&gt; ./Submit<span class="number">-1.</span>sh</span><br><span class="line">-bash: ./Submit1.sh: /bin/bash^M: bad interpreter: No such file or directory</span><br></pre></td></tr></table></figure>
<p>很显然，是<code>/bin/bash^M</code>这里多了个<code>^M</code>导致在Linux下执行的时候无法识别命令，为什么会多出来一个<code>^M</code>呢？这得从Windows系统和Linux系统的换行标识符来说明。</p>
<p>在Windows系统下的换行标识为<code>\r\n</code>，而Linux格式的换行标识为<code>\n</code>。其中<code>\r</code>表示回车符，<code>\n</code>表示新的一行new line。为何Linux下的换行符不包含<code>\r</code>回车符呢？大概是因为在Linux下处理包含回车符的时候会引起一些程序出现问题，因此和Windows的格式不一致。显然Windows和Linux的格式不一致是众所周知的，然而没有在实际中真正遇到的时候，往往我们是不会意识到它们的差异。</p>
<p>回归正题，在Linux下，回车符显示为<code>^M</code>，而新换一行则用<code>$</code>表示，根据上面的分析，我们是在Windows环境下用<code>SubmitUpdater</code>生成<code>Submit-1.sh</code>-<code>Submit-N.sh</code>N份Shell脚本，Windows会给它们的行末加上换行标识<code>\r\n</code>，即便你在代码中明明写的是<code>\n</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">290</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> </span><br><span class="line">-M <span class="number">0.01</span> -U -Q -t <span class="number">0.1</span> -T <span class="number">0.05</span> -d <span class="number">1000</span> -v <span class="number">1513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> </span><br><span class="line">-g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> -i <span class="number">0.04</span> -l <span class="number">0.01</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> </span><br><span class="line">-K <span class="number">0.010000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中#!/bin/bash我是如下定义的， 虽然代码里用\n，然而由于是在Windows下生成，会被定义为\r\n</span></span><br><span class="line"><span class="keyword">char</span> firstLine[<span class="number">255</span>] = <span class="string">"#!/bin/bash\n"</span>;</span><br></pre></td></tr></table></figure>
<p>因此实际上，上面的<code>#!/bin/bash</code>末尾接了一个Windows下的换行标识<code>\r\n</code>，那么在Linux下显示的时候应该就是<code>#!/bin/bash^M$</code>，我们可以在Linux下通过<code>cat -A filename</code>命令来查看一个脚本文件是Windows格式还是Linux格式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hmliao@songdyn:~&gt; cat -A Submit<span class="number">-1.</span>sh</span><br><span class="line"><span class="meta">#!/bin/bash^M$</span></span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">290</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> </span><br><span class="line">-M <span class="number">0.01</span> -U -Q -t <span class="number">0.1</span> -T <span class="number">0.05</span> -d <span class="number">1000</span> -v <span class="number">1513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> </span><br><span class="line">-g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> -i <span class="number">0.04</span> -l <span class="number">0.01</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> </span><br><span class="line">-K <span class="number">0.010000</span></span><br><span class="line">hmliao@songdyn:~&gt;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到<code>#!/bin/bash^M$</code>这是Windows格式，显然不是Linux能够识别的<code>#!/bin/bash$</code>，既然是格式不对，能想到的解决方法不外乎就是<strong>进行格式转换</strong>或者<strong>直接生成Linux格式的文件</strong>。</p>
<h3 id="u4E09-__u89E3_u51B3_u65B9_u6848"><a href="#u4E09-__u89E3_u51B3_u65B9_u6848" class="headerlink" title="三. 解决方案"></a>三. 解决方案</h3><p><strong>1. 格式转换</strong><br>Google搜了搜格式转换的方法琳琅满目，很多都是这样的情况：用各种文本编辑器打开文件，然后转存为Linux格式。这当然是一种方法，然而对于我的问题并不适用，我有几千份Windows格式的文件，一份份去转存终究是不现实，如果再写个程序来批处理这样的行为显然就没有意义。</p>
<p>对于我这样的，已经有大批量Windows格式的文件的问题，一种可行的格式转换方法是通过Linux下的<code>dos2unix</code>命令（当然了，同样也有<code>unix2dos</code>），然后在Linux服务器上用<code>dos2unix</code>命令写个循环的脚本文件，就可以轻松的完成格式转换。然而又出现一个问题了，我的Linux服务器上出现<code>-bash: dos2unix: command not found</code>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmliao@songdyn:~&gt; dos2unix Submit<span class="number">-1.</span>sh</span><br><span class="line">-bash: dos2unix: command not found</span><br></pre></td></tr></table></figure>
<p>估计是得安装一下，然而我的账号并没有权限，由于我是通过cygwin/ssh的方式来连接Linux服务器，一个可行的办法是在cygwin模拟的Linux环境下安装<code>dos2unix</code>，然后批量转格式，然后上传到服务器进行计算。</p>
<ul>
<li>首先下载<a href="https://github.com/liaohuming/SubmitUpdater/blob/master/files/apt-cyg" target="_blank" rel="external">「apt-cyg」</a>保存的文件名为apt-cyg，没有后缀，然后放到你的cygwin安装目录下的/bin目录里面，然后修改apt-cyg给执行权限，参考以下命令</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /bin/apt-cyg</span><br></pre></td></tr></table></figure>
<ul>
<li>然后运行cygwin的安装包，在选择包的页面安装wget，如图，接着等待安装完成</li>
</ul>
<p><img src="/img/cygwin.png" alt="安装wget"></p>
<ul>
<li>最后打开cygwin终端，执行<code>apt-cyg install dos2unix</code>进行安装。</li>
</ul>
<p>此方法经测试有效，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hxl650@BoLi-PC /home</span><br><span class="line">$ dos2unix Submit<span class="number">-1.</span>sh</span><br><span class="line">dos2unix: converting file Submit<span class="number">-1.</span>sh to Unix format...</span><br></pre></td></tr></table></figure>
<p>可以看到转换后的文件，没有了<code>^M</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat -A Submit<span class="number">-1.</span>sh</span><br><span class="line">hxl650@BoLi-PC /home</span><br><span class="line"><span class="meta">#!/bin/bash$</span></span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">290</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> </span><br><span class="line">-M <span class="number">0.01</span> -U -Q -t <span class="number">0.1</span> -T <span class="number">0.05</span> -d <span class="number">1000</span> -v <span class="number">1513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> </span><br><span class="line">-g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> -i <span class="number">0.04</span> -l <span class="number">0.01</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> </span><br><span class="line">-K <span class="number">0.010000</span></span><br></pre></td></tr></table></figure></p>
<p>再通过写个循环脚本就可以实现批量转换了，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">dir_id=<span class="number">1</span></span><br><span class="line">submitName=Submit-</span><br><span class="line">submitSuffix=.sh</span><br><span class="line"><span class="keyword">while</span> test $dir_id -le $<span class="number">1</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">dos2unix $submitName$dir_id$submitSuffix</span><br><span class="line">dir_id=`expr $dir_id + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>批量转换格式后上传到Linux服务器进行计算，则通过<strong>格式转换</strong>的途径解决了这个问题，但是这他妈的也实在是太繁琐了吧，简直不能忍，也就是一直不甘心一直想把它成功转换，我才坚持把这个方法做通，但是太繁琐了，不推荐。如果有兴趣倒不妨尝试一下。</p>
<p><strong>2. 直接生成Linux格式的文件</strong></p>
<p>前面说过了，不外乎转格式和直接生成正确格式两种方法。现在就简单说说直接生成Linux格式的文件的方法，前面说了半天那么详细的说，为什么到这里就简单说说了呢，那是因为这个方法太简单了。</p>
<p>第一，如果是用文本编辑器手动编辑的脚本文件，那在保存的时候注意一下保存的格式，比如说windows的文本编辑器notepad，在保存的时候，选择为Unix格式的，这样传到Linux服务器的时候格式就没有问题了。当然还有其他很多种文本编辑器了，一样的，就是保存格式设置一下。当然这种情况对我的需求并不适用，我有成百上千份文件，我不可能手动一份创建然后保存。所以需要写程序来做这些工作，也就是前面提到的<code>SubmitUpdater</code>，用<code>SubmitUpdater</code>来生成成百上千份的文件，似乎又回到了需要进行前面格式转换的问题了是不是？其实只要不要在Windows下编译<code>SubmitUpdater</code>即可，把编译工作放到Linux服务器上去做，然后在Linux下执行<code>SubmitUpdater</code>，直接生成Linux格式的脚本文件，这才是正道。不要纠结怎么进行格式转换了，虽然研究起来也蛮有意思。</p>
<p>第二，要把程序放到Linux上去编译，那得自己写makefile了，然而不写不知道，写了才知道makefile有多简单，下面是一个非常好的教程<a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D" target="_blank" rel="external">「跟我一起写Makefile:MakeFile介绍」</a>，推荐学习，此处不再赘述了。</p>
<h3 id="u56DB-__u53C2_u8003_u8D44_u6599"><a href="#u56DB-__u53C2_u8003_u8D44_u6599" class="headerlink" title="四. 参考资料"></a>四. 参考资料</h3><p><a href="http://bencane.com/2014/02/11/converting-files-from-windows-format-to-unix-format-with-dos2unix//" target="_blank" rel="external">1. Converting files from Windows format to Unix format with dos2unix</a><br><a href="http://www.wjxfpf.com/2015/10/486084.html" target="_blank" rel="external">2. cygwin $’\r’: command not found 解决 dos2unix</a><br><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D" target="_blank" rel="external">3. 跟我一起写Makefile:MakeFile介绍</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4E00-__u95EE_u9898_u63CF_u8FF0"><a href="#u4E00-__u95EE_u9898_u63CF_u8FF0" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h3><p>在<]]>
    </summary>
    
      <category term="Linux" scheme="http://liaohuming.net/tags/Linux/"/>
    
      <category term="笔记" scheme="http://liaohuming.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Aero Engine, How it works-航空发动机工作原理]]></title>
    <link href="http://liaohuming.net/2016/02/13/20160213-Aero%20Engine,%20How%20it%20works-%E8%88%AA%E7%A9%BA%E5%8F%91%E5%8A%A8%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://liaohuming.net/2016/02/13/20160213-Aero Engine, How it works-航空发动机工作原理/</id>
    <published>2016-02-13T22:51:42.000Z</published>
    <updated>2016-03-23T02:13:57.551Z</updated>
    <content type="html"><![CDATA[<p>We don’t even think twice any more about taking an airplane to get from one place to another, but do you know what it takes to power an airplane? There are many excellent videos on <strong>Youtube</strong> detailed explains how it works, unfortunately most of my friends <strong>in China</strong> they just can not use these resources conveniently, thus I plan to share some interesting videos about aero engine here and then upload them to <a href="http://i.youku.com/liaohuming" target="_blank" rel="external"><strong>my Youku</strong></a>. Wish the knowledge and the niceness can be spread more widely.</p>
<p>Okay, let’s plunge into the incredible world of aero engines and see how they work. </p>
<h3 id="1-_An_very_interesting_informative_film_from_CFM"><a href="#1-_An_very_interesting_informative_film_from_CFM" class="headerlink" title="1. An very interesting informative film from CFM"></a>1. An very interesting informative film from CFM</h3><p>CFM International (the 50/50 Joint Venture of Safran and GE) allows you to see inside a jet engine through this entertaining, yet very informative film. It will show you the basic operating principles for a modern turbofan engine with a high bypass ratio, and the state-of-the-art technologies incorporated in CFM’s new-generation LEAP engine.</p>
<iframe height="500" width="700" src="http://player.youku.com/player.php/sid/XMTQ3Mjg1NDUyMA==/v.swf" frameborder="0" allowfullscreen></iframe>


<h3 id="2-_A_more_detailed_explanation_about_how_does_a_Jet_Engine_work"><a href="#2-_A_more_detailed_explanation_about_how_does_a_Jet_Engine_work" class="headerlink" title="2. A more detailed explanation about how does a Jet Engine work"></a>2. A more detailed explanation about how does a Jet Engine work</h3><p>The working of a jet engine is explained in this video in a logical and illustrative manner with help of animation. This video takes the viewer through 1-spool engine, 2-spool engine, turbo jet engine and turbofan engine.</p>
<iframe height="500" width="700" src="http://player.youku.com/player.php/sid/XMTQ3MTMxNDY0OA==/v.swf" frameborder="0" allowfullscreen></iframe>


<h3 id="3-_GEnx_-_How_a_jet_engine_works"><a href="#3-_GEnx_-_How_a_jet_engine_works" class="headerlink" title="3. GEnx - How a jet engine works"></a>3. GEnx - How a jet engine works</h3><p>A good overview of how a jet engine works. This specific example is the General Electric GEnx that is used on the Boeing 787. This animation was produced by General Electric.</p>
<iframe height="500" width="700" src="http://player.youku.com/player.php/sid/XMTQ3Njc2ODE1Mg==/v.swf" frameborder="0" allowfullscreen></iframe>


<h3 id="4-_Rolls_Royce_-_How_To_Build_A_Jumbo_Jet_Engine"><a href="#4-_Rolls_Royce_-_How_To_Build_A_Jumbo_Jet_Engine" class="headerlink" title="4. Rolls Royce - How To Build A Jumbo Jet Engine"></a>4. Rolls Royce - How To Build A Jumbo Jet Engine</h3><p>A Documentary about Rolls Royce made by BBC (all rights reserved)….enjoy it!</p>
<iframe height="500" width="700" src="http://player.youku.com/player.php/sid/XMTQ3ODQwNTI5Ng==/v.swf" frameborder="0" allowfullscreen></iframe>


]]></content>
    <summary type="html">
    <![CDATA[<p>We don’t even think twice any more about taking an airplane to get from one place to another, but do you know what it takes to power an a]]>
    </summary>
    
      <category term="航空发动机" scheme="http://liaohuming.net/tags/%E8%88%AA%E7%A9%BA%E5%8F%91%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="笔记" scheme="http://liaohuming.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下批量运行测试算例的简单实现]]></title>
    <link href="http://liaohuming.net/2016/02/08/20160208-Linux%E4%B8%8B%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%AE%97%E4%BE%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://liaohuming.net/2016/02/08/20160208-Linux下批量运行测试算例的简单实现/</id>
    <published>2016-02-08T22:21:36.000Z</published>
    <updated>2016-02-25T04:02:14.621Z</updated>
    <content type="html"><![CDATA[<h3 id="u4E00-__u95EE_u9898_u63CF_u8FF0"><a href="#u4E00-__u95EE_u9898_u63CF_u8FF0" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h3><p>在<a href="http://liaohuming.net/2016/02/01/20160201-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%9A%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%97%B6getopt()%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/">「命令行多参数解析时getopt()函数的使用方法小结」</a>一文中介绍了如何用<code>getopt()</code>函数来进行多参数的解析，在该文的<strong>「三. 实例」</strong>中即用了<code>getopt()</code>函数对38个输入参数进行解析，这些参数用于测试某数值算法，而这些参数中的很大一部分，其参数的取值是有待寻优的，即是说，需要将这些参数在一定的取值范围内对各种取值的情况进行计算，最后分析计算结果找出最佳的参数组合，因而就需要不断的修改参数的取值，然后不断地提交计算。</p>
<p>该数值算法的测试程序为单线程且有若干输入文件及输出结构目录，为了减少测试过程中的手动操作，将采用一台64核Linux系统的服务器来进行测试。整个实现方案虽然很简单，由于平时Linux用得少，许多操作步骤用到一些不熟悉的指令，正所谓好记性不如烂笔头，为了避免日后出现再用到时又忘记而又需要重新花时间去琢磨的情况，在此就花一些时间把整个过程简单的梳理，做个备忘，以供日后参考。</p>
<h3 id="u4E8C-__u65B9_u6848_u6982_u8FF0"><a href="#u4E8C-__u65B9_u6848_u6982_u8FF0" class="headerlink" title="二. 方案概述"></a>二. 方案概述</h3><ul>
<li>测试文件：<code>submit.sh</code>启动程序（参数在此定义）、<code>vos.gcc_v714M.st</code>主程序、<code>mesh.dat</code>输入文件；<code>fluid</code>、<code>solid</code>输出目录，所有这些文件同在一个目录下，如下图所示：</li>
</ul>
<p><img src="/img/test files.jpg" alt="测试文件"></p>
<ul>
<li><p>测试环境：64核Linux系统</p>
</li>
<li><p>测试方案：每次同时提交进行60份不同的参数进行测试计算</p>
</li>
</ul>
<h3 id="u4E09-__u5B9E_u73B0_u8FC7_u7A0B"><a href="#u4E09-__u5B9E_u73B0_u8FC7_u7A0B" class="headerlink" title="三. 实现过程"></a>三. 实现过程</h3><p><font color="red">1. 为submit.sh启动程序和vos.gcc_v714M.st主程序增加执行权限<font></font></font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加执行权限</span></span><br><span class="line">chmod u+x submit.sh</span><br><span class="line">chmod u+x vos.gcc_v714M.st</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消执行权限</span></span><br><span class="line"><span class="comment">// chmod u-x submit.sh</span></span><br><span class="line"><span class="comment">// chmod u-x vos.gcc_v714M.st</span></span><br></pre></td></tr></table></figure>
<p>增加执行权限后的效果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r--. <span class="number">1</span> hmliao hmliao      <span class="number">460</span> Feb  <span class="number">6</span> <span class="number">02</span>:<span class="number">23</span> submit.sh*</span><br><span class="line">-rwxrw-r--. <span class="number">1</span> hmliao hmliao      <span class="number">460</span> Feb  <span class="number">6</span> <span class="number">02</span>:<span class="number">23</span> vos.gcc_v714M.st*</span><br></pre></td></tr></table></figure></p>
<p>说明：<br>第一列共有10个位置，即：<code>-rwxrw-r--</code><br>第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。<br>从第二个字符开始到第十个共9个字符，3个字符一组，上例中的三组分别是：<code>‘rwx’</code>,<code>‘rw-’</code>，<code>‘r--’</code>分别表示了<strong>u，g，o，3组用户</strong>对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。</p>
<p>u 代表所有者（user）<br>g 代表所有者所在的组群（group）<br>o 代表其他人，但不是u和g （other）<br>a 代表全部的人，也就是包括u，g和o<br>r 表示文件可以被读（read）<br>w 表示文件可以被写（write）<br>x 表示文件可以被执行（如果它是程序的话）</p>
<p><font color="red">2. 批量创建计算文件<font></font></font></p>
<p>每计算一次都需要<code>submit.sh</code>、<code>vos.gcc_v714M.st</code>、<code>mesh.dat</code>、<code>fluid</code>和<code>solid</code>这些文件，为了同时计算n次（本例中为60次，下面皆以60次为例进行说明），需要为每次计算准备独立的目录，所以接下来要做的事情是，批量生成60个计算文件夹，再将这5分文件批量复制到各个文件夹中，然后修改每次计算的输入参数<code>submit.sh</code>，输入参数这个得手动修改了，除非测试的参数满足某种规律便于写脚本自动修改，否则就根据测试需求手动慢慢改吧。</p>
<p>批量生成文件夹及批量复制的脚本，命名为<code>CreateFiles.sh</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">dir_id=<span class="number">1</span>			</span><br><span class="line"><span class="keyword">while</span> test $dir_id -le $<span class="number">2</span>		</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir $<span class="number">1</span>$dir_id</span><br><span class="line">cp -r copyFiles<span class="comment">/*.* $1$dir_id</span><br><span class="line">cp -a fluid $1$dir_id</span><br><span class="line">cp -a solid $1$dir_id</span><br><span class="line">dir_id='expr $dir_id + 1'</span><br><span class="line">done</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p><code>test</code>是Linux里的一个命令，在本例中<code>test</code>的作用是评估一个表达式<code>$dir_id -le $2</code>,如果条件为真，则返回一个 0 值，同时执行do下面的命令。如果表达式不为真，则返回一个大于 0 的值，也可以将其称为假值，结束执行，即done。</p>
<p><code>$dir_id -le $2</code>这个表达式中<code>dir_id=1</code>，表示从1开始计数，<code>$2</code>表示用户通过命令行输入的第二个参数，这个参数在本例中就是要计算的次数n=60次。那么就简单了，<code>$dir_id -le $2</code>的含义：如果 $dir_id 小于或等于 $2，则为真，执行do后面的命令，否则结束循环。</p>
<p><code>mkdir $1$dir_id</code>中的<code>$1</code>表示用户通过命令行输入的第一个参数，在本例中的含义是测试文件夹的名称，例如test，<code>$1$dir_id</code>就表示test1、test2、……、test60，mkdir通过while循环来创建这60个文件夹。</p>
<p><code>cp -r copyFiles/*.* $1$dir_id</code>、<code>cp -a fluid $1$dir_id</code>、<code>cp -a solid $1$dir_id</code>这三条命令是拷贝文件，由于目录下还有其他一些文件，为了方便，本例将<code>submit.sh</code>、<code>vos.gcc_v714M.st</code>、<code>mesh.dat</code>统一放在copyFiles这个文件夹下，这里面只有这3个文件，没有其他干扰文件，复制起来简单方便，将这个文件下的所有文件通过while循环分布拷贝至60个文件夹中，同时再将输出结果的两个文件夹，也通过while循环拷贝至60个文件夹中。</p>
<p><code>dir_id=&#39;expr $dir_id + 1&#39;</code>这个是更新表达式，不用多说了。</p>
<p>执行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./CreateFiles.sh test <span class="number">60</span>	<span class="comment">// test为文件夹名称，自行定义，60为数量，自行定义</span></span><br></pre></td></tr></table></figure></p>
<p>效果<br><img src="/img/60 folders.jpg" alt="生成的60个文件夹，每个文件夹中含有上述的5份文件"></p>
<p><font color="red">3. 修改每次计算的输入参数<font></font></font></p>
<p>如前所述，输入参数这个得手动修改了，除非测试的参数满足某种规律便于写脚本自动修改，否则就根据测试需求手动慢慢改吧。</p>
<p><font color="red">4. 批量启动测试程序，并且这个测试需要后台运行<font></font></font></p>
<p>本例是用 Cgywin64 Terminal/ssh 登录了远程的 Linux 服务器，每一次的计算任务要花至少1天的时间，因此需要让命令提交后不受本地关闭终端窗口/网络断开连接的干扰。当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，一种简单有效的解决方法是让进程忽略 HUP 信号，60个文件夹下的计算程序都通过nohup的方式启动执行，把这个启动执行的过程同样也写成一个脚本，一键提交，这个脚本命名为<code>StartAll.sh</code></p>
<p>StartAll.sh<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">dir_name=test</span><br><span class="line">dir_id=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> test $dir_id -le <span class="number">60</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cd $dir_name$dir_id</span><br><span class="line">nohup ./submit.sh vos.gcc_v714M.st &amp;</span><br><span class="line">cd ..</span><br><span class="line">dir_id=`expr $dir_id + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>说明：<br><code>nohup ./submit.sh vos.gcc_v714M.st &amp;</code>，<code>nohup</code>表示忽略HUP信号，标准输出和标准错误缺省会被重定向到 nohup.out 文件中；<code>./submit.sh</code>是每次计算的输入参数文件，60次各不相同的，<code>vos.gcc_v714M.st</code>是计算主程序，都是一样的；在结尾加上<code>&amp;</code>来将命令放入后台运行。</p>
<p>整个思路即是：首先进入test1文件夹，用后台运行的方式启动程序，然后退出至主目录，通过循环进入test2，又启动程序，由此循环实现n=60次的启动。在主目录执行<code>./StartAll.sh</code>后可以看到所有60个程序都已经启动且是后台运行，如下图所示：</p>
<p><img src="/img/StartAll.jpg" alt="启动60个计算程序，后台运行"></p>
<p><font color="red">5. 计算完成后，必要的删除操作<font></font></font></p>
<p>计算完成后，可能需要批量删除文件及文件夹，下面的命令可能会用到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除目录，不管目录中有没有文件，会将一些隐藏的配置文件也删除，小心使用</span></span><br><span class="line">hmliao@songdyn:~&gt; rm -r /home/hmliao<span class="comment">/*</span><br><span class="line"></span><br><span class="line">// 强制删除，没有提示，会将一些隐藏的配置文件也删除，小心使用</span><br><span class="line">hmliao@songdyn:~&gt; rm -rf /home/hmliao/*</span></span><br></pre></td></tr></table></figure>
<p>上述为实现过程的备忘，若有更多操作，后续再进行更新。</p>
<p>2016年2月9日17:27:10<br>于克利夫兰</p>
<h2 id="u66F4_u65B0"><a href="#u66F4_u65B0" class="headerlink" title="更新"></a>更新</h2><p>前面顺利提交了测试算例，接下来是漫长繁琐的数据分析，然而数据分析并不一定要等到算例结束再开始，在算例计算的过程中，根据输出的数据，很容易就可以判别出哪些算例的结果是无效的，对于这些算例就没有必要再接着算下去，这个时候就需要把服务器上对应的进程给结束。那么现在问题来了，60个程序的名称都是一样的即<code>vos.gcc_v714M.st</code>，又是通过<code>./</code>的方式而不是绝对路径的形式提交，所以这个时候查看进程，无法分辨出60个<code>vos.gcc_v714M.st</code>分别属于哪个test，也即是无法轻易的找到对应关系，比如这个<code>vos.gcc_v714M.st</code>属于test1，而那个<code>vos.gcc_v714M.st</code>属于test2，类似这样。</p>
<p>不能轻易的分辨出对应关系，那么想要结束某个进程就不知道该如何下手了。</p>
<p>在Linux里查看进程，一般可用top和ps命令。top的效果如下图：</p>
<p><img src="/img/StartAll.jpg" alt="Top查看进行信息"></p>
<p>PID是每个进程的ID，所有进行都有自己的ID且唯一。在COMMAND那一列，可以看到程序的名称，这个时候我们发现前面提交的60个任务所有都叫同一个名字<code>vos.gcc_v714M.st</code>，这样如果想结束某个进行显然不知道对应关系，没法下手。</p>
<p>于是想通过ps命令来查看每个进程所运行的主程序的路径，也就是说它们各自属于哪个文件夹，我们前面定义了60个文件，如果现在能看到各个进程运行的主程序来自于哪个文件夹，这样对应关系就清楚了。于是尝试用下面的方式来查看详细的路径信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep vos.gcc_v714M.st</span><br></pre></td></tr></table></figure>
<p>然而由于是通过<code>./</code>的方式提交的，所以依然看不到程序的路径信息。</p>
<p>当然，一个蠢方法是可以看到路径信息的，那就是通过已知的PID，然后挨个去看，但这没有任何意义，这没有办法一次把所有的信息列出来，60个要去看60次，也不是想看哪个就能找到哪个，没有人会愿意这么做的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/PID/exe</span><br></pre></td></tr></table></figure>
<p>所以，这个问题没有得到解决。从计算的结果来看，目前测试的60组数据都不行，那么就把所有的进程一起结束了吧，多简单，有两种方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall vos.gcc_v714M.st <span class="comment">// 这个指的是结束所有指定名称的进程，测试没成功</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -uhmliao <span class="comment">// -u指的是用户名，hmliao是对应的用户，代表把该用户的所有进程结束，测试成功</span></span><br></pre></td></tr></table></figure>
<p>接下来要做的是，在下次提交的任务的时候，使得进行自带分辨信息，能想到的办法有两种，第一，提交的时候用绝对路径，那样的话用<code>ps aux|grep vos.gcc_v714M.st</code>这样的方式就可以看到每一个进程程序的路径，这样的方法能想像出有多麻烦，首先，提交的指令加上了绝对路径之后肯定很不清晰了，一大串一大串的，其次，查看进行的时候也是有一大串的路径信息，看花眼哟，所以这是一种不可取的选择，也就没有去尝试了。</p>
<p>最简单的莫过于把60个程序改下名字，加上编号或者其他任意需要的信息，然后通过top一看便知，这样就轻易的能找到某个我们想要的进程的PID，再想对它做点什么，还不是分分钟的事。</p>
<p>这样，就在原来<code>CreateFiles.sh</code>的基础上，把原来的单纯拷贝的操作，改为拷贝并重命名即可实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">dir_id=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> test $dir_id -le $<span class="number">2</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir $<span class="number">1</span>$dir_id	</span><br><span class="line">cp -r copyFiles<span class="comment">/*.* $1$dir_id</span><br><span class="line">cp -f vos.gcc_v714M.st $1$dir_id/$1$dir_id.st  //把原来在copyFiles里的vos.gcc_v714M.st复制并重命名</span><br><span class="line">cp -a fluid $1$dir_id</span><br><span class="line">cp -a solid $1$dir_id</span><br><span class="line">dir_id=`expr $dir_id + 1`</span><br><span class="line">done</span></span><br></pre></td></tr></table></figure>
<p>StartALL.sh也做相应的调整<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">dir_name=test</span><br><span class="line">dir_id=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> test $dir_id -le <span class="number">61</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cd $dir_name$dir_id</span><br><span class="line">nohup ./submit.sh $dir_name$dir_id.st &amp;  <span class="comment">// 启动的是对应的修改后的名称</span></span><br><span class="line">cd ..</span><br><span class="line">dir_id=`expr $dir_id + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>最后通过top来查看，效果如下，对应信息一目了然，想结束哪个直接可以看到其对应的PID。</p>
<p><img src="/img/StartAll-named.jpg" alt="Top查看进行信息"></p>
<p>若干参考资料：<br>1.<a href="http://linuxtools-rst.readthedocs.org/zh_CN/latest/tool/ps.html" target="_blank" rel="external">ps 进程查看器</a><br>2.<a href="http://www.ha97.com/2523.html" target="_blank" rel="external">Linux的pkill和pgrep命令详解</a><br>3.<a href="http://www.ahlinux.com/start/cmd/2610.html" target="_blank" rel="external">linux对文件进行复制、移动(重命名)、删除的命令详解</a><br>4.<a href="http://init7.blog.51cto.com/860934/180474" target="_blank" rel="external">一个很好的命令(pkill)，一次性杀死某用户所有进程。PS：其他杀进程命令</a></p>
<p>若有更多操作，后续再进行更新。<br>2016年2月11日13:46:13</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4E00-__u95EE_u9898_u63CF_u8FF0"><a href="#u4E00-__u95EE_u9898_u63CF_u8FF0" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h3><p>在<]]>
    </summary>
    
      <category term="Linux" scheme="http://liaohuming.net/tags/Linux/"/>
    
      <category term="笔记" scheme="http://liaohuming.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于读书的随想]]></title>
    <link href="http://liaohuming.net/2016/02/05/20160206-%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6%E7%9A%84%E9%9A%8F%E6%83%B3/"/>
    <id>http://liaohuming.net/2016/02/05/20160206-关于读书的随想/</id>
    <published>2016-02-06T04:25:57.000Z</published>
    <updated>2016-02-25T03:41:43.755Z</updated>
    <content type="html"><![CDATA[<p>一直很喜欢阅读，但阅读对我而言已经是很遥远的事情了，能算得上阅读的，最近的也只能追溯到大二大三那会儿了，也就是2007，2008年那段时间，无事的时候便去学校那碉堡似的图书馆去找一些书来看，远离了浮躁，看完一个又一个故事，一时间好似回到了03年的那个夏天：中考结束了，一波三折后终于是被我们镇上的中学录取了。接下来的每天，白天和爸爸妈妈进大坪山里做事，晚上在家里看水浒看得热火朝天，兴奋得常常凌晨一两点都不睡，这在九、十点就是万籁俱寂的农村，真是别样的感受，那会哥哥已在县一中读书了，我整天一个人，劳作让我得到锻炼，阅读让我感到充实。长长的暑假结束后，依旧清晰的记得9月份开学后的第一个晚自习，黑乎乎的我突然见到很多的新同学，像是进城了一样，那天的晚霞很美。</p>
<p>倒是啊，在北航的这些年常常觉得孤独，常常觉着自己无趣，多少个风雨过后的黑夜，踉踉跄跄独自走过三馆前那片伸手不见五指的小树林，无数个这样的夜里，这条走过千遍万遍的路啊，在脚下却是高高低低总也踩不准，走着走着就撞上了周围的树木，这种感觉就和我现在被禁锢的日子一般，挣扎在铜墙铁壁里处处碰壁，这夜黑得似乎永远不会有黎明的到来，这片树林长得似乎无穷无尽永远都走不出去，而我的生活似乎总也回不到正轨。这样的时候啊，我或者亢奋的唱起许巍的“蓝莲花”释放胸中的豪情，或者呢喃着齐秦的“夜夜夜夜”舒尽心底的柔情，这样的光景，我便常常不好意思起来，担心会有人听到，但跌跌撞撞总归能走出这一片黑暗。呵，就是这样的黑夜，很有奋斗的感觉，也是这样的夜，觉着自己好孤独，更觉着自己是个无趣的人，我的精力和热情多半被繁杂的项目一点点消耗，于是我变得越来越孤独，也许孤僻更合适，越来越无趣，每天只想着怎么完成任务。很显然我和现实的关系有些紧张了，这是必然的结果，长期单调索然无味的生活工作，缺乏交流、缺乏阅读。缺乏交流的结果是对他人的现状缺乏了解以致交流中出现缺乏共同话题而产生厌倦社交的潜意识暗示；而缺乏阅读则更甚，现在大都只读工具书，工具书读了很多，虽是提升了技能，并不能给精神带来滋养，一个干涸扭曲的灵魂，是不可能带来美好的，这才是万恶的根源，而通过阅读、写作、经历、感悟等诸多途径的自我锻炼是有可能获得所期待的美好的，想必那会儿会把自身的这种美好称为修养了吧，是的，因为这是一个修炼的过程，然而要达到这样泰然自若的极佳状态，没有任何人能够帮助你，非得身体力行不可，庆幸向往美好是人的本性，就像肚子饿了本能地会去找食物一样，现在的我又对阅读有了如饥似渴的需求，而一旦开始，在每天的阅读里我非常轻易的就获得了快乐，每一天都收获着美好，书中自有黄金屋，书中自有颜如玉，书中还有美金书签呢。呵，多棒。</p>
<p>接下来我会持续在本篇博文中更新列出今年所读完的书，并简单附上一句两句若干句即时的随想，到16年年末，看看这一年都会看完了哪些书，看看有什么有趣的事情发生。</p>
<hr>
<p><strong>1.《春风沉醉的晚上》</strong></p>
<p>这是买来kindle后读完的第一本，郁达夫的短篇小说。很短，耐人寻味，常常都会带着一种美好去想邓脱路贫民窟的作者和陈二妹后面怎么样了，他们的生活是否都有好转？</p>
<p><strong>2.《活着》</strong></p>
<p>余华的长篇小说，我是在和师弟去Costco的路上开始看的，我不爱出去，来到这该死的克利夫兰之后，每周的超市购物尤其让我头疼，非要我一起去的时候索性在车上看书吧，去的路上有点堵，比往常慢了许多，故事就从爱骑着胖妓女去老丈人门口大声打招呼的败家子福贵身上开始了……，读着有味。逛完超市去理发的路上总觉着时间太短，按预约时间到了理发店见到乌泱泱的前来理发的人占了我们的预约我倒暗自高兴起来，可以接着读这个故事。那天后面，半夜睡不着，起来一口气把剩下的故事读完，好的作品就是有这样的魅力，可是读着读着就不那么美好了，福贵接下来的故事开始让人愤怒、鄙视、可怜、同情、感动、感慨，一系列的感情变化。故事里写出了人对苦难的承受能力，对世界乐观的态度，那种绝望中的希望是那么的有力量。</p>
<p>于2016年2月6日01:15:08</p>
<p><strong>3.《兄弟》</strong></p>
<p>余华的长篇小说，分上下两部。上半部分，在文革的浪潮中，兄弟俩的父亲成为了文革的牺牲品，兄弟俩的母亲成为了接下来艰苦生活的牺牲品，随着父母的离去，精神狂热，本能压抑和命运惨烈的文革时代过去了。下半部分是近现在的故事，是一个伦理颠覆、浮躁纵欲和众生万象的时代。在小说中连接这两个时代的纽带是这兄弟两人，他们的生活在裂变中裂变，他们的悲喜在爆发中爆发，他们的命运和这两个时代一样天翻地覆，最终他们恩怨交集地自食其果。人性是复杂的，自私的弟弟、没有主见的哥哥、善变的女人，是我能够想到的并不贴切的评价。</p>
<p>于2016年2月13日16:04:24</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直很喜欢阅读，但阅读对我而言已经是很遥远的事情了，能算得上阅读的，最近的也只能追溯到大二大三那会儿了，也就是2007，2008年那段时间，无事的时候便去学校那碉堡似的图书馆去找一些书来看，远离了浮躁，看完一个又一个故事，一时间好似回到了03年的那个夏天：中考结束了，一波三]]>
    </summary>
    
      <category term="读书" scheme="http://liaohuming.net/categories/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[命令行多参数解析时getopt()函数的使用方法小结]]></title>
    <link href="http://liaohuming.net/2016/02/01/20160201-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%9A%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%97%B6getopt()%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://liaohuming.net/2016/02/01/20160201-命令行多参数解析时getopt()函数的使用方法小结/</id>
    <published>2016-02-01T17:13:48.000Z</published>
    <updated>2016-02-25T04:02:20.695Z</updated>
    <content type="html"><![CDATA[<p>在Linux中，用命令行执行可执行文件时，常常涉及到：<strong>大量、不同类型、不同形式的</strong> 输入参数问题。从简单的说起，现在假设有我们一个用户定义的可执行程序，名为<code>test.sh</code>，它需要3个输入参数，于是我们通过命令行去执行它的时候，往往通过如下的做法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="u4E00-_main_u51FD_u6570"><a href="#u4E00-_main_u51FD_u6570" class="headerlink" title="一. main函数"></a>一. main函数</h3><p>上面的<code>./test.sh</code>是执行程序，<code>1、2、3</code>是<code>test.sh</code>的输入参数，这些命令项通过传递给程序的main函数进行处理，main函数的一般形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>argc是一个整型，argv是一个指针数组，argc记录argv的大小，例如<code>./test.sh 1 2 3</code>将被以如下的方式传递：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argc=<span class="number">4</span>；</span><br><span class="line">argv[<span class="number">0</span>]=./test.sh;</span><br><span class="line">argv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">argv[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">argv[<span class="number">3</span>]=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="u4E8C-_getopt_u51FD_u6570"><a href="#u4E8C-_getopt_u51FD_u6570" class="headerlink" title="二. getopt函数"></a>二. getopt函数</h3><p>现在我们考虑更复杂一些的输入要求，还是以<code>test.sh</code>为例，不过这时它的输入参数要更多一些了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh <span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span> -a <span class="number">4</span> -b <span class="number">5</span> -c <span class="number">6</span> -Q -S -T  <span class="comment">// 此处仅作为示例，还可以有更多更复杂参数，见后续实例</span></span><br></pre></td></tr></table></figure>
<p>先说说这一行参数表示什么意思，这里的破折号<code>-</code>表示这是一个控制选项，例如<code>-1</code>，在此处1是单字符选项，而<code>-a 4</code>表示带参数的选项，a是该选项的标识符，4是随同该选项一同传入的参数，<code>-Q</code>，与<code>-1</code>一样，Q也是单字符选项，没有随同的输入参数。通过定义不同的选项，我们可以在<code>test.sh</code>中定义丰富的操作完成各种各样的计算任务，但是这个时候main函数可没有办法给你完成上面的解析工作，main函数只是将<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>传递进来，保存在argc和argv里，至于这些参数如何分配并对应什么操作则是需要用户自行定义了，当然，自己写解析函数是可行的，但是有更好的选择。</p>
<p>在C语言中，<code>unistd.h</code>提供的<code>getopt()</code>这个函数，结合<code>switch</code>语句，可以帮助我们方便实现参数解析。</p>
<p>先看例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line">  <span class="keyword">while</span> ( (opt=getopt(argc, argv, <span class="string">"123a:b:c:QST"</span>)) != <span class="number">-1</span> ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> (opt) </span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">      para1 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">      para2 = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">      para3 = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">      para4 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">      para4 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">      para5 = atof(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Q'</span>:</span><br><span class="line">      definedOption1 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">      definedOption2 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">      definedOption3 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">	……</span><br><span class="line">	&#125;</span><br><span class="line">	……</span><br><span class="line">  &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>getopt()函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>int argc, char * const argv[]</code>一般是直接通过读取main函数的argc和argv，而optstring则是用户定义的选项字符，例如在上面的例子中，optstring是 <code>123a:b:c:QST</code> ，它用来解析输入参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>，并且是由用户定义。</p>
<p>字符串optstring的元素一般可分为下面几种：</p>
<ul>
<li>单个字符，表示选项，<code>123a:b:c:QST</code>中的1、2、3、Q、S、T都是单字符选项</li>
<li>单个字符后接一个冒号<code>:</code>表示该选项后必须跟一个参数。参数紧跟在选项后以空格隔开。该参数的指针赋给optarg。<code>123a:b:c:QST</code>中的<code>a:</code>, <code>b:</code>, <code>c:</code> 都表示它们需要附加指定输入参数，这就是为什么在输入参数时是<code>-a 4 -b 5 -c 6</code>的缘故</li>
<li>单个字符后跟两个冒号<code>::</code>表示该选项后<strong>可选地</strong>跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张，本例中不作介绍）。</li>
</ul>
<p>同时，getopt()在unistd.h中的相关定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* <span class="keyword">extern</span> <span class="keyword">char</span> *optarg;  <span class="comment">//选项的参数指针</span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> optind,    <span class="comment">//下一次调用getopt的时，从optind存储的位置处重新开始检查选项。 </span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> opterr,    <span class="comment">//当opterr=0时，getopt不向stderr输出错误信息。</span></span><br><span class="line">* <span class="keyword">extern</span> <span class="keyword">int</span> optopt;    <span class="comment">//当命令行选项字符不包括在optstring中或者选项缺少必要的参数时,</span></span><br><span class="line">                        <span class="comment">//该选项存储在optopt中，getopt返回'?'</span></span><br></pre></td></tr></table></figure>
<p>那么现在就清楚用户输入的参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>是怎么进行传递和解析的了：</p>
<ul>
<li>通过main函数将输入参数<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>保存在argc和argv</li>
<li>getopt()按照<code>123a:b:c:QST</code>这个规则去解析argc和argv中保存的数据</li>
<li>例如，首先去<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>读取到的选项是<code>-1</code>（第一个输入参数./test.sh是执行程序是名称不予考虑），于是就去<code>123a:b:c:QST</code>中检查是否有<code>1</code>这个选项，有的话就返回该选项（这个时候就会转入相应的case执行对应的操作），同时将选项索引optind更新为输入参数的下一个位置(此处为<code>-2</code>的位置)作为下次搜索的开始位置，如果在optstring里没有找到<code>1</code>，例如我们的optstring是<code>23a:b:c:QST</code>，即当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回<code>&#39;?&#39;</code>，并从optind开始进行下一个输入参数的解析</li>
<li><p>继续解析，当解析到<code>-a</code>时，这个时候getopt()发现optstring里的<code>a</code>后面跟着<code>:</code>于是它知道a是还需要传递进来一个指定的参数，于是就将指针*optarg指向-a后面的一个参数即是4，这样返回选项a的时候，a所对应的参数值此时由optarg指向，这样转入<code>case &#39;a&#39;</code>的时候就可以对该参数进行相应的操作了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">  para4 = atof(optarg);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着往下走，-Q -S -T与前面的-1是一样的，都是不带参数的单字符选择，当检查完-T后，返回-1，表示检查完毕，这个时候就完成了对<code>./test.sh -1 -2 -3 -a 4 -b 5 -c 6 -Q -S -T</code>中所有参数的分配工作。</p>
</li>
</ul>
<p>上述简单介绍了命令行多参数解析时getopt()函数的用法，若有错误，欢迎斧正与探讨；若干概念引自文献[1]，若有需要相关概念更详细的解释，可前往阅读。</p>
<h3 id="u4E09-__u5B9E_u4F8B"><a href="#u4E09-__u5B9E_u4F8B" class="headerlink" title="三. 实例"></a>三. 实例</h3><p>在Eureka中进行的FSI数值算例中用到如下控制选项，整理出来作为备忘。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">./$<span class="number">1</span> <span class="number">-2</span> -L <span class="number">290</span> -H <span class="number">120</span> -J <span class="number">0.1</span> -h <span class="number">8.0</span> -D <span class="number">500</span> -r <span class="number">1.5</span> -c <span class="number">1.0e-5</span> -x <span class="number">3.1</span> -b <span class="number">1.6</span> -q <span class="number">1</span> -R <span class="number">1</span> -M <span class="number">0.01</span> </span><br><span class="line">-U -Q -t <span class="number">0.1</span> -T <span class="number">0.1</span> -d <span class="number">1000</span> -v <span class="number">513</span> -f <span class="number">1</span> -G <span class="number">1.0e7</span> -k <span class="number">1.42e5</span> -p <span class="number">1.18e-6</span> -g <span class="number">1.4</span> -m <span class="number">0</span> -s <span class="number">1.82e-5</span> </span><br><span class="line">-i <span class="number">0.1</span> -l <span class="number">10.0</span> -I <span class="number">0.0</span> -A <span class="number">0.0</span> -E <span class="number">2.5e6</span> -P <span class="number">1e-4</span> -N <span class="number">0.35</span> -n <span class="number">8</span> -K <span class="number">10.0</span></span><br><span class="line"></span><br><span class="line">解析</span><br><span class="line">getopt(argc, argv, <span class="string">"23L:H:W:J:h:D:r:c:x:b:q:R:M:SQUt:T:d:v:f:G:k:p:g:m:s:i:l:I:A:E:P:N:n:K:"</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>控制符</strong></th>
<th><strong>值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>./$1</td>
<td></td>
<td>执行程序名称，e.g. verification_oscillation_structure.gcc_v714M.st</td>
<td></td>
</tr>
<tr>
<td>-2</td>
<td>2</td>
<td>二维</td>
<td></td>
</tr>
<tr>
<td>-3</td>
<td>3</td>
<td>三维</td>
<td></td>
</tr>
<tr>
<td>-L</td>
<td>290</td>
<td>Length</td>
<td></td>
</tr>
<tr>
<td>-H</td>
<td>120</td>
<td>Height</td>
<td></td>
</tr>
<tr>
<td>-W</td>
<td>0</td>
<td>Width</td>
<td></td>
</tr>
<tr>
<td>-J</td>
<td>0.1</td>
<td>critical_shear/maximum shear strain</td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>8</td>
<td>element size that determines the patch thickness 入口单元尺寸</td>
<td></td>
</tr>
<tr>
<td>-D</td>
<td>500</td>
<td>Domain_End 计算域终点，计算域起点为0.0</td>
<td></td>
</tr>
<tr>
<td>-r</td>
<td>1.5</td>
<td>searchRange, parameters for the shape function</td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>1.0e-5</td>
<td>cutoff, parameters for the shape function</td>
<td></td>
</tr>
<tr>
<td>-x</td>
<td>3.1</td>
<td>extension, parameters for the shape function</td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>1.6</td>
<td>beta, parameters for the shape function</td>
<td></td>
</tr>
<tr>
<td>-q</td>
<td>1</td>
<td>integration_order q=1表示单元的中心插入1个质量点</td>
<td></td>
</tr>
<tr>
<td>-R</td>
<td>1</td>
<td>nRing 邻域控制，1表示从单元本身节点开始，如果变形大，可以设置为2</td>
<td></td>
</tr>
<tr>
<td>-M</td>
<td>0.01</td>
<td>mass_factor</td>
<td></td>
</tr>
<tr>
<td>-S</td>
<td>true</td>
<td>adaptive_search</td>
<td></td>
</tr>
<tr>
<td>-Q</td>
<td>true</td>
<td>adaptive_beta</td>
<td></td>
</tr>
<tr>
<td>-U</td>
<td>true</td>
<td>updateNeighbor</td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>0.1</td>
<td>time step ratio 0.1表示10%</td>
<td></td>
</tr>
<tr>
<td>-T</td>
<td>0.1</td>
<td>total_time simulation time</td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>1000</td>
<td>dump，number of time steps to visualize the results</td>
<td></td>
</tr>
<tr>
<td>-v</td>
<td>513</td>
<td>max velocity of inflow，speed</td>
<td></td>
</tr>
<tr>
<td>-f</td>
<td>1.0</td>
<td>parameters for the rupture of solids，epsilon_h=1 包含裂纹扩展</td>
<td></td>
</tr>
<tr>
<td>-G</td>
<td>1.0e7</td>
<td>parameters for the rupture of solids</td>
<td></td>
</tr>
<tr>
<td>-k</td>
<td>1.42e5</td>
<td>the bulk modulus of fluid (2.1e9 Pa for water) 体积模量</td>
<td></td>
</tr>
<tr>
<td>-p</td>
<td>1.18e-6</td>
<td>the density of fluid (1.0e3 kg/m^3 for water)</td>
<td></td>
</tr>
<tr>
<td>-g</td>
<td>1.4</td>
<td>Gruneisen parameter in the equation of state of the fluid</td>
<td></td>
</tr>
<tr>
<td>-m</td>
<td>0</td>
<td>nuf，poisson’s ratio of the fluid</td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>1.82e-5</td>
<td>the shear viscosity coefficient of fluid (1.82e-5kg/(m.s))动力粘度</td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>0.1</td>
<td>artificial viscosity coefficient to stablize the simulation 经验系数</td>
<td></td>
</tr>
<tr>
<td>-l</td>
<td>10</td>
<td>artificial viscosity coefficient to stablize the simulation 经验系数</td>
<td></td>
</tr>
<tr>
<td>-I</td>
<td>0.0</td>
<td>artificial viscosity coefficient to stablize the simulation 经验系数</td>
<td></td>
</tr>
<tr>
<td>-A</td>
<td>0.0</td>
<td>artificial viscosity coefficient to stablize the simulation 经验系数</td>
<td></td>
</tr>
<tr>
<td>-E</td>
<td>2.5e6</td>
<td>E_Solid，Young’s modulus of solid 固体材料弹性模量</td>
<td></td>
</tr>
<tr>
<td>-P</td>
<td>1.0e-4</td>
<td>rho_Solid，density of solid 固体材料密度</td>
<td></td>
</tr>
<tr>
<td>-N</td>
<td>0.35</td>
<td>nu_Solid，Poisson’s ratio of solid 固体材料泊松比</td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>8</td>
<td>number of threads 线程数</td>
<td></td>
</tr>
<tr>
<td>-K</td>
<td>10</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="u56DB-__u53C2_u8003_u6587_u732E"><a href="#u56DB-__u53C2_u8003_u6587_u732E" class="headerlink" title="四. 参考文献"></a>四. 参考文献</h3><p>[1] <a href="http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html#Using-Getopt" target="_blank" rel="external">http://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html#Using-Getopt</a></p>
<p>2016年2月1日16:18:12<br>于克利夫兰</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Linux中，用命令行执行可执行文件时，常常涉及到：<strong>大量、不同类型、不同形式的</strong> 输入参数问题。从简单的说起，现在假设有我们一个用户定义的可执行程序，名为<code>test.sh</code>，它需要3个输入参数，于是我们通过命令行去执行]]>
    </summary>
    
      <category term="C++" scheme="http://liaohuming.net/tags/C/"/>
    
      <category term="笔记" scheme="http://liaohuming.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我所理解的C++类设计中的private成员变量和返回const引用类型]]></title>
    <link href="http://liaohuming.net/2016/01/21/20160121-%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84C++%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B8%ADprivate%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%94%E5%9B%9Econst%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://liaohuming.net/2016/01/21/20160121-我所理解的C++类设计中private成员变量和返回const引用类型/</id>
    <published>2016-01-21T05:57:23.000Z</published>
    <updated>2016-02-25T04:02:25.806Z</updated>
    <content type="html"><![CDATA[<p>从读研究生开始接触编程，都是根据项目需求，完成任务为主，学习很被动，虽然编了不少东西，但是鲜有对本质的东西有透彻的理解，缺乏指导是一个原因，缺乏总结才是更主要的原因，所以产生了写这篇文章的想法，适时的提炼总结，是提升自我的重要途径。</p>
<p>简单说说现在现在的需求：为了测试数值算法，需将有限元前处理器HyperMesh生成的网格文件按Eureka格式进行转换，网格文件格式已知，目标文件格式已知，那么要做的事情就是把网格文件解析，然后按目标格式存储即可实现目标，这是一般的做法。</p>
<p>如果以后换了一种格式，那么可能又要重新写过转换程序了，并没有通用性。能想到的解决方法，自然是设计一个类，这个类和输出什么格式没有任何关系，这个类只是单纯的将网格文件的所有有效数据（例如：nodes、elements、sets等等）保存在类中，用户只需要直接引用或继承这个类，就可以访问到所有的网格数据，进而根据自己的需求输出想要的格式。</p>
<p>这样的思路，其实是数据解析、数据存储（类来保存）、数据重组（用户自定义）的过程，由于输出不是这个类考虑的，而是由用户来决定，因此有了通用性。</p>
<p>在设计这个类的时候遇到了几个问题，下面说说：</p>
<h3 id="u4E00-__u5C06_u6210_u5458_u53D8_u91CF_u58F0_u660E_u4E3Aprivate"><a href="#u4E00-__u5C06_u6210_u5458_u53D8_u91CF_u58F0_u660E_u4E3Aprivate" class="headerlink" title="一. 将成员变量声明为private"></a>一. 将成员变量声明为private</h3><p>最开始我是用public的，简单嘛，这也是我一直以来的做法，<a href="http://engineering.case.edu/emae/Faculty/Bo_Li" target="_blank" rel="external">Li Bo</a> 老师看了之后提出了修改要求，作为一个完善、安全、高效的类，必须把成员变量声明为私有类型，即private，如果你没有用过，你就一直没有概念，我就是这样，于是我找了《C++ Primer》和《Effective C++》相关的内容补充了一下概念，最重要的是封装性。</p>
<p><strong>封装性</strong></p>
<p>成员变量声明为private后，只能通过成员函数进行访问，因此如果以后对成员变量有改动，例如以某个计算替换这个成员变量或者是其他的一些改动，使用这个类的用户并不知道，也不会受到影响，顶多重新编译一下。</p>
<p>将成员变量声明为private后就对使用这个类的用户隐藏了成员变量，即封装，这样便确保了class的约束条件总是会获得维护，因为只有成员函数可以影响它们，并且保留了日后变更实现的权利。如果不隐藏它们，我们很快会发现，即使拥有class原始代码，改变任何public事物的能力还是极端受到束缚，因为那会破坏太多的用户代码。public意味着不封装，不封装意味着不可改变，特别是对被广泛使用的classes而言。</p>
<p>假设我们有一个public成员变量，而我们修改甚至最终取消了它，那么多少代码会被破坏呢？取决于该class被使用的范围，如果就你自己用，可能修改代码的工作量是可以接受的，如果有更多一些人用，那么被破坏的代码就是一个未知量，往往是很大的。</p>
<p>一旦你将一个成员变量声明为public而用户开始使用它，就很难改变那个成员变量涉及的一切，太多的代码需要重写、重新测试、重新编写文档和重新编译，可见在一个类的设计之初，考虑周全是多么的重要。</p>
<p>除了public类型之外，protected类型同样也存在封装问题（此处不展开），因此从封装的角度，就只有两种访问权限：<strong>private提供封装</strong> 和 <strong>其他不提供封装</strong>。</p>
<p>上述封装讨论源自参考文献[1]并结合我的理解。</p>
<h3 id="u4E8C-__u5C06_u8BBF_u95EEprivate_u6210_u5458_u53D8_u91CF_u7684_u6210_u5458_u51FD_u6570_u5B9A_u4E49_u4E3A_u201C_u8FD4_u56DEconst_u5F15_u7528_u7C7B_u578B_u201D"><a href="#u4E8C-__u5C06_u8BBF_u95EEprivate_u6210_u5458_u53D8_u91CF_u7684_u6210_u5458_u51FD_u6570_u5B9A_u4E49_u4E3A_u201C_u8FD4_u56DEconst_u5F15_u7528_u7C7B_u578B_u201D" class="headerlink" title="二. 将访问private成员变量的成员函数定义为“返回const引用类型”"></a>二. 将访问private成员变量的成员函数定义为“返回const引用类型”</h3><p>前面讲到了将成员变量声明为private，通过提供成员函数来访问这些private变量。那么现在就有一个问题，这些成员函数怎么设计才合适呢？基于本文的目的是想将这个class设计成适用于各种有限元计算，这个类只要将Hypermesh网格文件作为输入，这个类便完全提取并保存了数据，这些数据可以直接被用户在各自的有限元计算代码中调用，也可以按用户的指定的格式输出。对于第一种直接应用的情况，由于网格数量巨大，计算过程中有大数量级的数据操作，因此我们需要从成员函数访问private变量的效率方面进行考虑。</p>
<p><font color="red"><strong>首先说说引用类型</strong><font></font></font></p>
<p>“引用类型”（reference type）是C++的一种<strong>变量类型</strong>，它的作用是为变量起一个别名。<br>假如有一个变量a，想给它起一个别名，可以这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure></p>
<p>这就表明了b是a的“引用”，即a的别名。经过这样的声明，使用a或b的作用相同，都代表同一变量。在上述引用中，&amp;是“引用声明符”，并不代表地址，可以这样理解：在这里int&amp;是一种变量类型，它和int、double、string一样，都是一种变量的类型。不要理解为“把a的值赋给b的地址”。</p>
<p><font color="red"><strong>其次说说函数返回值</strong><font></font></font></p>
<p>在这里主要讨论返回值的类型为：引用类型和非引用类型</p>
<p>函数返回值用于初始化在调用函数时创建的临时对象(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值拷贝给临时对象，这样的话，每调用一次该函数就会得到一个新的拷贝值。因此如果我们设计的成员函数，获得的是private变量的一个拷贝，那么在大数级量的操作中就会消耗不可估量的内存，因此对于这种问题，需要我们的成员函数获得的是private变量的一个引用，由于计算过程中的调用，并没有拷贝变量，而是直接引用原对象，因此能节约内存同时不需要拷贝也提高了效率。</p>
<p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; AskElementData(<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3);</span><br><span class="line"></span><br><span class="line">上面复杂的函数其实是以下这个形式：</span><br><span class="line"></span><br><span class="line"><span class="function">type&amp; <span class="title">FunctionName</span><span class="params">(type&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>type&amp; FunctionName()</strong>即代表，函数返回的是引用类型，这样，成员函数返回的则是引用。</p>
<p><font color="red"><strong>然后说说返回const引用类型</strong><font></font></font></p>
<p>试想，类中保存着诸多的数据，单元节点、节点坐标等，由于我们提供的成员函数是对原private变量的直接引用，用户对该引用的任何修改都是直接对原变量的修改，这样会导致数据的不安全，即便一般情况下用户不会主动去修改原始数据，但是不排除误操作的情况，从数据安全角度，应该从类的设计上杜绝这种修改的可能性，而不是靠用户的自律性来维护。<strong>在这里突然很想说个个人观点，一个社会不应该靠社会成员的自律性来维护正常秩序，而应该是通过完善的体制来维护。</strong>只是突然想到的。回归正题，那么const关键字则提供了这样的功能，const类型的引用，既避免了复制的低效高耗操作又能防止用户直接对引用变量进行修改的可能，多么好，是吧。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">	tria3 = _element_tria3; <span class="comment">// _element_tria3为类的private变量</span></span><br><span class="line">	return tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>接下来谈谈对type&amp; functionName(type&amp;)中形参type&amp;的困惑</strong><font></font></font></p>
<p>由于我之前的编程经验都是野路子，并没有太多系统的知识，在明白了<strong>const type&amp; functionName()</strong>之后，还有一个困惑，那就是为什么函数的形参中需要一个引用类型的参数<strong>(type&amp;)</strong>呢？</p>
<p>这还得从返回的变量说起，如果我们的成员函数定义的是返回非引用类型，那么它是可以返回局部变量的，因为返回非引用类型，返回的是原变量的一个拷贝值，所以，当成员函数执行完毕，在它函数体内定义的局部变量虽然被销毁，但是返回的是该局部变量的一个拷贝值，这个拷贝值独立于原变量，所以这样用是没有问题的。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; Hypermesh::AskElementData()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; tria3; <span class="comment">// 局部变量</span></span><br><span class="line">	tria3 = _element_tria3; <span class="comment">// _element_tria3为类的private变量</span></span><br><span class="line">	return tria3; </span><br><span class="line">	<span class="comment">// 返回的是tria3的一个拷贝，所以当AskElementData()执行完毕，</span></span><br><span class="line">	<span class="comment">// tria3被销毁，AskElementData()返回的拷贝值是依然存在可用的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果我们定义的成员函数是返回引用类型，当成员函数执行完毕时，将释放分配给局部变量的存储空间，此时对局部变量的引用就会指向不确定的内存，返回指向局部变量的指针也是一样的，当函数结束时，局部变量被释放，返回的指针就变成了不再存在的变量的悬垂指针。</p>
<p>例如下面这种做法是错误的：返回局部变量的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt; element_tria3; <span class="comment">// 局部变量</span></span><br><span class="line">	tria3 = element_tria3; <span class="comment">// 对局部变量的引用</span></span><br><span class="line">	return tria3; <span class="comment">// 返回的是对局部变量的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>那么就明确了，如果你的成员函数要返回的是对变量的引用，那么它不可以是局部变量。</strong></p>
<p><strong>而，返回非局部变量的引用时，要求在函数的形参中，包含有以引用方式或指针方式存在的，需要被返回的参数。</strong></p>
<p>例如我们现在所讨论的类中的private成员变量，下面的做法也是错误的，因为它的形参中没有提供以引用方式或指针方式存在的，需要被返回的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3 = _element_tria3; <span class="comment">// 对private变量的引用</span></span><br><span class="line">	return tria3; <span class="comment">// 引用类型变量tria3是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的用法应该是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3) <span class="comment">// 提供一个引用方式存在的需要返回的参数</span></span><br><span class="line">&#123;</span><br><span class="line">	tria3 = _element_tria3;</span><br><span class="line">	return tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>最后总结一下</strong><font></font></font></p>
<p>根据前面的需求分析，本文设计的类需要：</p>
<ul>
<li>类的成员变量为私有类型private</li>
<li>用来访问private成员变量的是返回const引用类型的成员函数</li>
</ul>
<p>所以最后采用的是下面这个形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; Hypermesh::AskElementData(</span><br><span class="line"><span class="built_in">vector</span>&lt;hypermeshElement_tria3&gt;&amp; tria3)</span><br><span class="line">&#123;</span><br><span class="line">	tria3 = _element_tria3;</span><br><span class="line">	return tria3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> type&amp; <span class="title">FunctionName</span><span class="params">(type&amp; xx)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	xx = privateObject;</span><br><span class="line">	return xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于这方面的总结大概就是这些了，日后若有进一步的理解再进行补充。<br>以上内容皆为个人理解，有错之处欢迎斧正和讨论。</p>
<p>2016年1月21日03:23:06<br>于克利夫兰</p>
<h3 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] 《Effective C++》第三版，条款22。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从读研究生开始接触编程，都是根据项目需求，完成任务为主，学习很被动，虽然编了不少东西，但是鲜有对本质的东西有透彻的理解，缺乏指导是一个原因，缺乏总结才是更主要的原因，所以产生了写这篇文章的想法，适时的提炼总结，是提升自我的重要途径。</p>
<p>简单说说现在现在的需求：为]]>
    </summary>
    
      <category term="C++" scheme="http://liaohuming.net/tags/C/"/>
    
      <category term="笔记" scheme="http://liaohuming.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[If you never try, you will never know.]]></title>
    <link href="http://liaohuming.net/2016/01/06/If%20you%20never%20try,%20you%20will%20never%20know/"/>
    <id>http://liaohuming.net/2016/01/06/If you never try, you will never know/</id>
    <published>2016-01-07T04:34:52.000Z</published>
    <updated>2016-02-25T04:03:46.184Z</updated>
    <content type="html"><![CDATA[<p>2015-12-7<br>Writing</p>
<p>2015-12-8<br>Writing</p>
<p>2015-12-9<br>Reading</p>
<p>2015-12-10-?<br>I don’t know where is the end, I felt very discouraged.<br>Still reading and writing.</p>
<p>go on and on and on ……</p>
<p>……</p>
<p>2016-1-6<br>Done.</p>
<p>My first paper,<br>twenty-eight pages, ten thousand words.<br>If you never try, you will never know what you can do.<br>I am ready for the next challenge.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015-12-7<br>Writing</p>
<p>2015-12-8<br>Writing</p>
<p>2015-12-9<br>Reading</p>
<p>2015-12-10-?<br>I don’t know where is the end, I felt]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sealed With A Kiss]]></title>
    <link href="http://liaohuming.net/2015/11/23/20151123-Sealed%20With%20A%20Kiss/"/>
    <id>http://liaohuming.net/2015/11/23/20151123-Sealed With A Kiss/</id>
    <published>2015-11-23T18:46:50.000Z</published>
    <updated>2016-04-29T03:58:00.122Z</updated>
    <content type="html"><![CDATA[<p>It will be updated continually.</p>
<p><img src="/img/postcard20151123.jpg" alt="The first one - from Cleveland - on 2015.11.23."></p>
<p><img src="/img/postcard20151207.jpg" alt="The second one - from Cleveland - on 2015.12.07."></p>
<p><img src="/img/postcard20151226.jpg" alt="The third one - from Niagara falls - on 2015.12.26."></p>
<p><img src="/img/postcard20160125.jpg" alt="The fourth one - from Cleveland - on 2016.01.25."></p>
<p><img src="/img/postcard20160214.jpg" alt="The fifth one - from Cleveland - on Valentine&#39;s Day."></p>
<p><img src="/img/postcard20160301.jpg" alt="The sixth one - from Cleveland - on 2016.03.01"></p>
<p><img src="/img/postcard20160322.jpg" alt="The seventh one - from Cleveland - on 2016.03.22"></p>
<p><img src="/img/postcard20160426.jpg" alt="The eighth one - from Cleveland - on 2016.04.26"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>It will be updated continually.</p>
<p><img src="/img/postcard20151123.jpg" alt="The first one - from Cleveland - on 2015.11.23."></p>
<p]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重拾]]></title>
    <link href="http://liaohuming.net/2015/04/02/20150402-%E9%87%8D%E6%8B%BE/"/>
    <id>http://liaohuming.net/2015/04/02/20150402-重拾/</id>
    <published>2015-04-03T01:13:38.000Z</published>
    <updated>2016-02-25T03:42:20.192Z</updated>
    <content type="html"><![CDATA[<p>13年5月后我就再也没有只言片语了，感觉把自己抛弃了一般，实是不应该。</p>
<p>与自己内心对话是非常重要的，虽然现在回看过去，感觉自己就是个神经病，但是我却非常怀念这样的状态。</p>
<p>嗯。重拾。</p>
<p><img src="/img/重拾.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>13年5月后我就再也没有只言片语了，感觉把自己抛弃了一般，实是不应该。</p>
<p>与自己内心对话是非常重要的，虽然现在回看过去，感觉自己就是个神经病，但是我却非常怀念这样的状态。</p>
<p>嗯。重拾。</p>
<p><img src="/img/重拾.jpg" al]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[就像一个被抛弃的孩子一样无助]]></title>
    <link href="http://liaohuming.net/2012/08/06/20120806-%E5%B0%B1%E5%83%8F%E4%B8%80%E4%B8%AA%E8%A2%AB%E6%8A%9B%E5%BC%83%E7%9A%84%E5%AD%A9%E5%AD%90%E4%B8%80%E6%A0%B7%E6%97%A0%E5%8A%A9/"/>
    <id>http://liaohuming.net/2012/08/06/20120806-就像一个被抛弃的孩子一样无助/</id>
    <published>2012-08-06T23:49:48.000Z</published>
    <updated>2016-02-25T03:42:26.960Z</updated>
    <content type="html"><![CDATA[<p>去年的时候，一个老同学好朋友，向我买淘宝账号，说想开个小店。</p>
<p>自从上研后，我便不再繁于业务，虽是不再用了，但是这相伴我多年的账号，这许些年的生活费都是它卖力挣得，这即是另一个我。我断然是不会卖的，只是老朋友开口，又不好拒绝，于是就提出借用，并叮嘱一定好生照顾好这个账号。</p>
<p>只要想起来时就会去点击收藏夹中店铺的网址。就看看。<br>这种感觉就好像，每次回乡，心底里希望家乡的面貌越变越美好。</p>
<p>可是，说过的小店，从没成功出现过，隐约记得有过几个出售的商品，破烂不堪。<br>并不是卖的东西不好，只是一眼就可以令人看出，这是一个没有用心做事的人。<br>我想，也许，还不熟悉吧。</p>
<p>后来，点击网址，已是什么都没有了。<br>再后来，收到哥哥的电话，问我的号是不是被盗了，一直给他发不良信息。</p>
<p>当即，我便测试了账号，已是被锁定了，而据上次正常登陆时间也是大半年之前，近期被盗被用于群发广告。<br>想必老同学已是非常久都没登过了。</p>
<p>打了个电话过去，问是否还在用，却回答说，一直都在用，前几天都还在传东西上去。<br>我说号被盗了，很久都没有登陆过了。<br>于是改口说，上个月还用过。<br>我说你还要用就用吧，被盗了，你先把号找回来吧，别一直发骗人的信息。<br>好好好。</p>
<p>好多天，过去了，好好好，也不见动静。<br>见你于如此水深火热，我还指望着他人。<br>突然对自己的愚蠢感到无尽的愤怒。<br>通过与客服的各种验证，终于要回了账号。</p>
<p>这一登陆，已是面目全非，所有分组下的好友显示名，都被程序加上数字编号，用于群发信息。<br>看着一个个熟悉的id，竟然都成了这样，心痛不已。</p>
<p>我曾经是那么的爱惜你，多少次追着那些愚蠢的买家解释，各种赔偿，只为保持住你100%的好评。<br>而如今我却将你抛弃，我不曾想到这是让你过起了有后妈的日子，我更不曾想到，会是这么糟蹋你。</p>
<p>我把一切信息都修改回我自己的信息。<br>对不起，我让你这么长一段时间，像一个被抛弃的孩子一样无助。</p>
<p>如果觉得自己坦诚相待是没有错的，那么也不要觉得别人占有欲太强也是有错的。<br>如果觉得自己善始善终是没有错的，那么别人就是做事有头无尾就有错吗？</p>
<p>老同学还是老同学，好朋友还是好朋友。<br>对自己有意义的东西，不见得对别人就有。<br>正确的处事方式，不见得别人就认同。</p>
<p>自己能做到的事，每次都做到即可，也不能强求别人就一定也要这么做。</p>
<p>无论如何，将心爱的东西借给别人，而遭受迫害。<br>罪魁祸首都应该是自己。</p>
<p>只是，如果是我借到了朋友心爱的东西，我想我会倍加珍爱的。<br>没有什么是不可以拒绝的，该拒绝的就拒绝，我想这是处事成熟与否的标志。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>去年的时候，一个老同学好朋友，向我买淘宝账号，说想开个小店。</p>
<p>自从上研后，我便不再繁于业务，虽是不再用了，但是这相伴我多年的账号，这许些年的生活费都是它卖力挣得，这即是另一个我。我断然是不会卖的，只是老朋友开口，又不好拒绝，于是就提出借用，并叮嘱一定好生照顾好]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[愿今天的傻逼会成为明日的弥足珍贵]]></title>
    <link href="http://liaohuming.net/2012/04/16/20120416-%E6%84%BF%E4%BB%8A%E5%A4%A9%E7%9A%84%E5%82%BB%E9%80%BC%E4%BC%9A%E6%88%90%E4%B8%BA%E6%98%8E%E6%97%A5%E7%9A%84%E5%BC%A5%E8%B6%B3%E7%8F%8D%E8%B4%B5/"/>
    <id>http://liaohuming.net/2012/04/16/20120416-愿今天的傻逼会成为明日的弥足珍贵/</id>
    <published>2012-04-16T21:58:58.000Z</published>
    <updated>2016-02-25T03:42:31.917Z</updated>
    <content type="html"><![CDATA[<p>上周六，秋嫂考研成功宴请在京人士，秋哥也终有闲暇，给我过起生日来了，众人大喜，豪饮醉归。<br>第二天醒来，头晕脑胀，不知昨夜如何归来，只觉饥肠辘辘，于是三步并作两步走，于路就近找了些东西填肚子。</p>
<p>吃完饭，想起昨夜是骑单车去赴宴的，现在它却不知在何处了，一时情感泛滥，内心愧疚无限。<br>于是信步来到东北虎菜馆，看看小车尚在否，放眼扫去，目及之处，并无你的身影。<br>于是又来到教学区北门看了看，亦不在此，无奈醉意未退，头晕的很，拖着疲惫的身子便回去了。</p>
<p>晚上吃饭的时候，秋哥说，明天你去买车，买过一辆新的。<br>我却没有萌生这样的想法，倒是不缺这三五百块钱。<br>总是觉着，事情不该是这样的，甚至我都还没搞明白是被偷了还是被我遗失在哪个角落了。<br>我要找到你，即便最后没有结果，我也要让自己内心拥有一份曾经努力过的平静。</p>
<p>新欢有的仅仅是欢，旧爱虽旧却是爱。</p>
<p>于是中午又来到东北虎菜馆，此次甚为仔细，盯着每辆车子看，都觉得像，如果车子是人，我敢保证其中的一些都被我盯得不好意思了。<br>可却是没有你。</p>
<p>我想想，还会在哪呢？就还剩东南门的车棚和教学区小南门没去了。<br>我纵身越过天桥楼梯的栅栏，跳上天桥楼梯，快速穿过天桥，来到东南门车棚。</p>
<p>眼前一亮，眼前又一亮，终究不是。</p>
<p>拖着疲惫的脚步，沿着北航新建的还未命名的艺术馆走着，懒懒的看着楼前破旧的车子。<br>看看你们失魂落魄的样子吧，想必你们也是被主人抛弃了。</p>
<p>看着路上匆匆行人，感受头上灼灼烈日，突然一种孤独寂寞冷涌上心头。<br>心里不禁害臊想到，找一辆单车至于弄得像找情人似的落魄么。</p>
<p>在逸夫楼前，我说，算了吧，回去。<br>可脚步却迈向了最后一个未去的地方。</p>
<p>现实版的众里寻你千百度，走着看着，终见你在小南门栅栏停车处。<br>再见到暖暖阳光下灰头土脸的你，安静如斯。<br>此刻，不是拥有新欢的激动和快乐，而是找回旧爱的平静和踏实。</p>
<p>你是否曾埋怨过我，骑在你身上这么多年，只一个晚上工夫就把你抛弃了呢？<br>呵，这么形容有点花花公子无情郎的味道。我想我不是，所以我出现了。</p>
<p>还记得有多少次，你在努力的最后时刻因为没有坚持下去而放弃了？<br>还记得有多少人，你在懵懵懂懂间就莫名其妙的不欢而散了呢？</p>
<p>也许，只要再多坚持一会，就成功了。<br>也许，只要一回头，就会发现，其实那人一直都在，从未走远。</p>
<p>在哪里跌倒的在哪里爬起来，在哪里失去的在哪里找寻回来。<br>愿今天的傻逼会成为明日的弥足珍贵。</p>
<p><img src="/img/愿今天的傻逼会成为明日的弥足珍贵.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上周六，秋嫂考研成功宴请在京人士，秋哥也终有闲暇，给我过起生日来了，众人大喜，豪饮醉归。<br>第二天醒来，头晕脑胀，不知昨夜如何归来，只觉饥肠辘辘，于是三步并作两步走，于路就近找了些东西填肚子。</p>
<p>吃完饭，想起昨夜是骑单车去赴宴的，现在它却不知在何处了，一时情]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[疲惫的一天]]></title>
    <link href="http://liaohuming.net/2012/04/09/20120409-%E7%96%B2%E6%83%AB%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <id>http://liaohuming.net/2012/04/09/20120409-疲惫的一天/</id>
    <published>2012-04-09T23:30:54.000Z</published>
    <updated>2016-02-25T03:42:37.237Z</updated>
    <content type="html"><![CDATA[<p>四月份的北京城，天气大好，饥肠辘辘的忙了一天，拖着疲惫的身体，穿过洒满斜阳的校园…<br>吃完饭，回寝室冲个凉，又是精神焕发，于是整装再出发<br>路上，路过蛋糕店，买了些，路过饮料店，买了些…</p>
<p>踩着单车，听着亢奋的曲子，享受着这美妙的时光…<br>还有，教学区北门，锁车时遇到的那个天然呆的小女孩…</p>
<p>一切都是那么的美妙，我想，用不了多久，我就会开始怀念这样的生活了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>四月份的北京城，天气大好，饥肠辘辘的忙了一天，拖着疲惫的身体，穿过洒满斜阳的校园…<br>吃完饭，回寝室冲个凉，又是精神焕发，于是整装再出发<br>路上，路过蛋糕店，买了些，路过饮料店，买了些…</p>
<p>踩着单车，听着亢奋的曲子，享受着这美妙的时光…<br>还有，教学]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[坚强与脆弱]]></title>
    <link href="http://liaohuming.net/2012/03/01/20120301-%E5%9D%9A%E5%BC%BA%E4%B8%8E%E8%84%86%E5%BC%B1/"/>
    <id>http://liaohuming.net/2012/03/01/20120301-坚强与脆弱/</id>
    <published>2012-03-02T01:37:58.000Z</published>
    <updated>2016-02-25T03:42:42.904Z</updated>
    <content type="html"><![CDATA[<p>总是在病痛的时候才想起健康的重要，<br>也总是在病痛的时候方才意识到自己是多么的脆弱，<br>我的脆弱则体现在从小到大我总是不断的生病不断的生病。</p>
<p>这几天总是噩梦连连，<br>每天早上起来，对着镜中的自己，笑笑。<br>新的一天，多美好。</p>
<p>如果可以将每个人的身体比作一个世界，<br>那么在我的世界里每天都进行着世界大战，<br>我的坚强则体现在我依然好好的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>总是在病痛的时候才想起健康的重要，<br>也总是在病痛的时候方才意识到自己是多么的脆弱，<br>我的脆弱则体现在从小到大我总是不断的生病不断的生病。</p>
<p>这几天总是噩梦连连，<br>每天早上起来，对着镜中的自己，笑笑。<br>新的一天，多美好。</p>
<p>如果]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我真想说你XX]]></title>
    <link href="http://liaohuming.net/2012/01/31/20120131-%E6%88%91%E7%9C%9F%E6%83%B3%E8%AF%B4%E4%BD%A0/"/>
    <id>http://liaohuming.net/2012/01/31/20120131-我真想说你/</id>
    <published>2012-02-01T01:47:31.000Z</published>
    <updated>2016-02-25T03:42:48.008Z</updated>
    <content type="html"><![CDATA[<p>乘火车，春运<br>一朋友发消息，关心问道，吃了吗？</p>
<p>从中午到傍晚<br>来来回回的小推车<br>也竟然只有瓜子水和水果<br>餐车也堵得可望不可及</p>
<p>我便毫不夸张地如是回之<br>怎奈朋友来了一通<br>这什么车啊，这么不人性……<br>我真想说你XX……</p>
<p>简单的说<br>是把列车以及其服务数落了一顿<br>顺带也把我数落了一顿</p>
<p>真是躺着也能中枪<br>虽然此时我已是饿得意识模糊了<br>但我心态是很好的<br>被这么一顿骂，顿时觉得挺饱的</p>
<p>只是<br>你是特地来骂我的吗<br>我想应该是知道我的行程，来关问我的</p>
<p>可如何第二句就转变成责骂了呢<br>联想到在现实中，如斯情况，实是不乏<br>噢，不对，不用联想，我这就是了</p>
<p><strong>如果你本意是去做一件事情，那就绝不要将其做成另一件</strong></p>
<p>我们原本是好意去做一件事，可却达到了相反的效果，自己还不知道，这是很可怕的<br>“我真想说你XX ……”<br>手法真挫劣，分明都已经说了，还假惺惺的用“真想”来掩饰</p>
<p><strong>不要一旦有机会便肆无忌惮地放纵那颗批判的心与优越的正义感</strong></p>
<p>还是回到，我提供给朋友的，半天没在春运列车上买到泡面和盒饭的信息<br>仅一句话，就殃及多少无辜，“不人性，你真XX，不可思议……”</p>
<p>我正愤愤的想着怎么把这毫无逻辑的批评写清楚呢<br>载着盒饭的亲爱的小推车就一脸无辜的表情朝着我艰难的推过来了</p>
<p>春运啊，这是春运啊，人性，人性啊，人性就是应该体谅啊<br>突然获得一种，一切尽在不言中的释放感</p>
<p>是吧，我们的正义感永远都是那么的优越<br>电脑用多的坏处就是什么都不用脑<br>往往都是未经思考就能得出结论</p>
<p>这样不好。</p>
<p>我这也等于尖酸刻薄地数落了一顿我那倒霉的朋友</p>
<p>这样也不好。</p>
<p>2012年1月31日<br>于北上的K572</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>乘火车，春运<br>一朋友发消息，关心问道，吃了吗？</p>
<p>从中午到傍晚<br>来来回回的小推车<br>也竟然只有瓜子水和水果<br>餐车也堵得可望不可及</p>
<p>我便毫不夸张地如是回之<br>怎奈朋友来了一通<br>这什么车啊，这么不人性……<br>我真想说]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[生活是美好的]]></title>
    <link href="http://liaohuming.net/2012/01/30/20120130-%E7%94%9F%E6%B4%BB%E6%98%AF%E7%BE%8E%E5%A5%BD%E7%9A%84/"/>
    <id>http://liaohuming.net/2012/01/30/20120130-生活是美好的/</id>
    <published>2012-01-31T04:46:50.000Z</published>
    <updated>2016-02-25T03:42:54.777Z</updated>
    <content type="html"><![CDATA[<p>春节在家的这几天<br>很累，很不方便，洗个澡跟打场战似的</p>
<p>特别是哥哥初四回京后<br>我独自一人在家交际应酬</p>
<p>几乎就没有清醒的时候<br>几天下来，想办的事情，一件没办好<br>刚刚还因为喝醉了要安装饮水机，结果把过滤器摔碎了</p>
<p>无论怎么的不完美<br>在家的这些天，妈妈是很开心的，还有什么比这个更重要的呢？</p>
<p>也有，实质性的改善<br>家里的电路，一楼二楼都重装过了<br>债务也在哥哥的努力下已经还清了<br>房子也不漏雨了<br>……</p>
<p>明天，就要走了</p>
<p>大晚上的，刚刚永珍舅母，特意上来，给我送了一个红包<br>说，白天的时候来过了，但是家里没人<br>说，同一辈的兄弟，就属我最小了</p>
<p>前天，在永辉舅家喝酒，招招舅母，给我一个红包<br>说，明，别嫌舅母给的少</p>
<p>我是从来抵触这些的，但是这次，我欣然接受<br>我知道，你们是真的高兴</p>
<p>昨天，在马六哥家喝酒<br>马六哥说，前几年出事，赔了很多钱，现在还欠着近20万<br>现在开车，一年苦下来，利润有个四五万<br>30了，别人问，都只回答，比去年大一岁，酒后的他，哽咽道。</p>
<p>事实的残酷，现实的无奈</p>
<p>我回忆，小时候三兄弟在菜地里拔草，一起疯狂砍别人菜，最后吓得不敢回家的傻事<br>马六哥高兴的叫道，小时去炳炳姨家做客，天下雨，马六哥背着我，然后我和哥哥闹着，一路捡瓶子盖玩<br>……</p>
<p>我不会忘记的<br>日子，会越来越好过的</p>
<p>这次回家，感觉特别的温暖<br>终归是一家人，无论以前家庭之间有多大的矛盾<br>真的，都特别的渺小<br>在家里最困难的时候，来帮助我们的总是你们</p>
<p>现在看到，两个外甥，争气有骨气<br>我知道，你们打心底也是高兴的</p>
<p>明早，回北京了</p>
<p>脚边，安静的睡着可爱的，小灰灰和小黑黑<br>再回来的时候，你们还记得我吗？</p>
<p>晚安，妈妈。<br>晚安，古田。</p>
<p>2012年1月30日<br>于古田</p>
<p><img src="/img/小灰灰和小黑黑.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>春节在家的这几天<br>很累，很不方便，洗个澡跟打场战似的</p>
<p>特别是哥哥初四回京后<br>我独自一人在家交际应酬</p>
<p>几乎就没有清醒的时候<br>几天下来，想办的事情，一件没办好<br>刚刚还因为喝醉了要安装饮水机，结果把过滤器摔碎了</p>
<p>无]]>
    </summary>
    
      <category term="随笔" scheme="http://liaohuming.net/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UG二次开发环境配置、UG版本、外部模式等问题及实例]]></title>
    <link href="http://liaohuming.net/2011/03/24/20110324-UG%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%81UG%E7%89%88%E6%9C%AC%E3%80%81%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%AD%89%E9%97%AE%E9%A2%98%E5%8F%8A%E5%AE%9E%E4%BE%8B/"/>
    <id>http://liaohuming.net/2011/03/24/20110324-UG二次开发中开发环境配置、UG版本、外部程序运行等问题及实例/</id>
    <published>2011-03-24T19:40:47.000Z</published>
    <updated>2016-03-30T03:26:13.691Z</updated>
    <content type="html"><![CDATA[<p>今天花一些时间把UG二次开发中较常遇到两个问题做一个简单的说明以供参考：</p>
<ul>
<li>UG二次开发中x86和x64版本问题</li>
<li>程序运行时缺失libufun.lib等库文件的问题</li>
</ul>
<p>并对如何配置开发环境进行说明，最后给出一个实例及演示视频：</p>
<ul>
<li>如何配置UG二次开发环境？</li>
<li>实例及视频演示</li>
</ul>
<hr>
<p><font color="red"><strong>(1) UG二次开发中x86和x64版本问题</strong><font></font></font></p>
<p>做UG二次开发时，版本问题一定要有清晰的概念，电脑分为x86（32位）和x64（64位）。UG软件的版本也有x86和x64之分。x86的UG，对应的是x86的支持库文件lib x86，x64的UG对应的支持库文件lib x64。</p>
<p>那么好了，x86的电脑只能安装x86的UG软件，一般在这样的环境下进行二次开发不会有太大的问题。</p>
<p>而x64的电脑，可以安装x64也可以安装x86的UG软件，这个时候，如果你要生成的x64的UG软件可以用的二次开发程序，你电脑里安装的UG得是x64的版本，这样在编译时候，用到的lib x64的库文件，因此你生成的dll或者exe可以在x64版本的UG中使用。</p>
<p>同理，如果要使生成的dll或者exe可以在x86的UG版本中使用，那么编译代码的时候提供的库文件得是x86版本的lib。</p>
<p>这些lib里包含了UG OpenAPI的实现，不同版本的会有不同，所以需要确保对应关系，方能确保程序正确运行。</p>
<p>小结：</p>
<p>x86 UG → x86 lib → 生成的dll或者exe是x86版本的  → 可以在 x86 UG上运行 → 可以在x86或者x64的电脑系统上运行</p>
<p>x64 UG → x64 lib → 生成的dll或者exe是x64版本的  → 可以在 x64 UG上运行 → 只能在x64位的电脑系统上运行</p>
<hr>
<p><font color="red"><strong>(2) 程序运行时缺失libufun.lib等库文件的问题</strong><font></font></font></p>
<p>这个应该是新手常常遇到的问题：在尝试UG的external模式时，遇到这个问题</p>
<p>具体情况是：对visual studio中的“附加包含目录”与“附加依赖性”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">附加包含目录：$(UGII_BASE_DIR)\ugopen</span><br><span class="line"></span><br><span class="line">附加依赖性：libufun.lib libugopenint.lib</span><br></pre></td></tr></table></figure>
<p>都做了正确的设置，而且也完全编译成功，但是这个编译成功的exe，运行时却弹出警告窗口，提示：“没有找到libufun.dll,因此这个应用程序未能启动。重新安装应用程序可能会修复此问题”</p>
<p>这是为什么呢？</p>
<p>在外部模式下，程序之所以不能运行，是因为缺dll 支持。所以光加了libufun.lib libugopenint.lib没有用，WINDOWS中，lib只是对dll中的接口函数的声明，像目录一样</p>
<p>外部开发，应该只能在UGII下可以运行，要么就找到libufun.dll和libugopenint.dll所引用的每一个库，也就是说把整个UGII中的文件夹打个包到exe所在的debug目录下。</p>
<p>目前了解到的解决办法是：</p>
<ul>
<li><p>直接将生成的exe文件拷贝到UGII目录下，双击运行，试过了，可以正常运行；</p>
</li>
<li><p>将整个UGII中的文件夹打个包到exe目录（没试过）</p>
</li>
</ul>
<p>这里有很好的讨论结果</p>
<p><a href="http://bbs.icax.org/viewthread.php?tid=145192&amp;extra=&amp;page=1" target="_blank" rel="external">http://bbs.icax.org/viewthread.php?tid=145192&amp;extra=&amp;page=1</a></p>
<p><font color="red"><strong>update：2011-3-28 17:02:22</strong><font></font></font></p>
<p>其实是少设置了环境变量的缘故</p>
<p>我的电脑-右键属性-高级-环境变量-系统变量-Path</p>
<p>添加UGII的路径，比如：D:\Program Files\UGS\NX 7.5\UGII</p>
<p>设置之后，生成的exe便可成功运行，而不会再提示找不到libufun.dll</p>
<p>之前上面所述其实道理一样，只是没有从本质上解决问题，通过设置环境变量之后便可不用将生成的exe文件复制到UGII目录下了。</p>
<p><font color="red"><strong>update：2012-3-12 16:29:39</strong><font></font></font></p>
<p>设置完Path后需要重启电脑。</p>
<hr>
<p><font color="red"><strong>(3) 如何配置UG二次开发环境？</strong><font></font></font></p>
<p>如何配置UG二次开发环境？下面以UG7.5在visual studio2015下的配置为例进行简单的说明。</p>
<p>1、设置：UGII_BASE_DIR<br>目的是为UGII目录下的库文件设置一个宏，在Visual Stuido配置附加包含目录的时候直接引用这个宏即可，而不需要在项目解决方案里直接设置软件的安装路径，这样一个好处就是，二次开发程序在不同的电脑里编译的时候，只要在不同的电脑里将宏所对应的路径做修改就可以，而不必去改项目解决方案属性中附加包含目录的值。</p>
<p>具体设置为：“我的电脑-右键属性-高级-环境变量-系统变量”，新建一个环境变量（一般UG安装的时候已经默认设置好了，如果没有就按此步骤设置）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名：UGII_BASE_DIR</span><br><span class="line"></span><br><span class="line">变量值：C:\Program Files\UGS\NX <span class="number">7.5</span>\UGII</span><br></pre></td></tr></table></figure>
<p>2、增加：UGII_USER_DIR<br>目的是告诉系统用户开发的程序放在哪里了，系统知道路径后在启动UG的时候会把用户开发的程序也进行加载，这样才能在程序里调用。用户路径需要设置为全英文的（可能新版本的UG已经支持中文了？没有去尝试），该路径下有两个目录<code>startup</code>和<code>application</code>，其中<code>startup</code>用于存放二次开发得到的dll，<code>application</code>用于存放采用UG风格的对话框文件等，一般如果是MFC开发，则只有dll都放<code>startup</code>，定义了这个环境变量后，在UG启动的时候会加载这个目录下的dll和对话框文件，从而使得可以在UG里调用。</p>
<p>具体设置为：“我的电脑-右键属性-高级-环境变量-系统变量”，新建一个系统变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名：UGII_USER_DIR</span><br><span class="line"></span><br><span class="line">变量值：C:\Users\hxl650\Desktop\UG_workspace</span><br></pre></td></tr></table></figure>
<p>3、设置：Path<br>这种情况主要是针对在外部模式下，程序不能运行的情况（详见本文的前半段:(2) 程序运行时缺失libufun.lib等库文件的问题）</p>
<p>4、在Visual studio中设置“附加包含目录”</p>
<ul>
<li>项目属性 - C/C++ - 常规 - 附加包含目录 - $(UGII_BASE_DIR)\ugopen</li>
<li>项目属性 - 链接器 - 常规 - 附加包含目录 - $(UGII_BASE_DIR)\ugopen</li>
</ul>
<p><img src="/img/ug1.png" alt="项目属性 - C/C++ - 常规 - 附加包含目录"><br><img src="/img/ug2.png" alt="项目属性 - 链接器 - 常规 - 附加包含目录"></p>
<p>5、在Visual studio中设置“附加依赖性”</p>
<ul>
<li>项目属性 - 链接器 - 输入 - 附加依赖项 - libufun.lib;libugopenint.lib;libnxopencpp.lib;libnxopenuicpp.lib;</li>
</ul>
<p><img src="/img/ug3.png" alt="项目属性 - 链接器 - 输入 - 附加依赖项"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前两项：libufun.lib;libugopenint.lib;是UGOPEN的</span><br><span class="line">后两项：libnxopencpp.lib;libnxopenuicpp.lib;是UGNXOPEN的</span><br><span class="line">根据需要自行设置</span><br></pre></td></tr></table></figure>
<hr>
<p><font color="red"><strong>(4) 实例及视频演示</strong><font><br><a href="https://github.com/liaohuming/UG-Redevelope-Demo.git" target="_blank" rel="external">另有一个简单的视频教程和实例代码，请戳此处前往我的Githup下载。</a></font></font></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天花一些时间把UG二次开发中较常遇到两个问题做一个简单的说明以供参考：</p>
<ul>
<li>UG二次开发中x86和x64版本问题</li>
<li>程序运行时缺失libufun.lib等库文件的问题</li>
</ul>
<p>并对如何配置开发环境进行说明，最后给出]]>
    </summary>
    
      <category term="UG 二次开发" scheme="http://liaohuming.net/tags/UG-%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://liaohuming.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
